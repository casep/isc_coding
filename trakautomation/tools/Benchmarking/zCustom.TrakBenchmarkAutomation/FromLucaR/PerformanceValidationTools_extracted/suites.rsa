Cache for Windows NT^INT^Suites-20010724^~Format=Cache.S~
%RO on 24 Jul 2001   3:36 PM
BigString.INT.1.58610,65255.
BigString       ;
 ; 
 ; 05/31/00 JMB Added IsUnicode check and build string data accordingly.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "BigString",!
 w "---------",!
 w "Stresses big strings (strings with lengths greater than 756).  This is",!
 w "primarily intended to be a network stress test.",!
 w !
 w "During each iteration, a job sets a global (unique to the job) to a string of",!
 w "random length (up to the maximum specified).  Then it fetches the value and",!
 w "compares it with the original string. If a string mismatch is discovered, all",!
 w "the jobs freeze so that they can be examined.",!
 w !
 w "This test depends on multiple jobs to be meaningful.  RAM761 recommends between",!
 w "20 and 30 jobs.",!
 w !
 w "Please use Start^BigString(jobs,length) to start this test.",!
 w "jobs   = number of jobs to start (default = 2)",!
 w "length = maximum length of generated string (default = 1280)",!
 w "The default values will start a minimal test.  However, as noted above, you",!
 w "may need to start a greater number of jobs for it to be meaningful.",!
 q
  
Start(jobs,length) 
 s $zt="errorTrap"
 d:$d(^BigString($zu(86),"PID")) Destroy
 s jobs=$g(jobs,2)
 s length=$g(length,1280)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs_" length="_length)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^BigString($zu(86),"PID")=jobs
 f i=1:1:jobs j Run(length)
 q
  
Status() 
 q:$d(^BigString("stop")) "SUSPENDED"
 q $$Status^Library("1""BigString""",2,15,"^BigString("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 d Stop^Library("^BigString("_$c(34)_$zu(86)_$c(34)_",""PID"")",30)
 q
  
Result() 
 n status,result,job,CRLF
 q:$d(^BigString($zu(86),"error")) "FAIL -- "_^BigString($zu(86),"error")
 q:$d(^BigString($zu(86)))=0 "FAIL -- Test data are missing."
 s CRLF=$c(13,10)
 s result=""
 s:$d(^BigString($zu(86),"stop")) result="Jobs suspended at "_^BigString($zu(86),"stop")_" due to mismatch."_CRLF
 s job=""
 f  s job=$o(^BigString($zu(86),"job",job)) q:job=""  d
 .  d:$d(^BigString($zu(86),"job",job,"expected"))
 .  .  s result=result_"Mismatch reported by job "_job_CRLF
 .  .  s result=result_"  set string size="_$l($g(^BigString("job",job,"expected")))_CRLF
 .  .  s result=result_"  get string size="_$l($g(^BigString("job",job,"actual")))_CRLF
 .  .  s:$d(^BigString($zu(86),"job",job,"same as previous")) result=result_"  same as previous"_CRLF
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" result_"PASS"
 q:$e(status,1,2)="OK" result_"FAIL -- Still running."
 q result_"FAIL -- "_status
  
Destroy 
 i $d(^BigString($zu(86))),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^bigString
 k ^BigString($zu(86))
 q
  
Run(length) 
 s $zt="errorTrap"
 s Unicode=$$IsUnicode^Library   ;Test for Unicode
 s ^BigString($zu(86),"PID",$j)=""
 s global=$name(^bigString($j))
 ;write message to cconsole.log
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^BigString($zu(86),"job",$j,"siz")=0
 s totlen=0
 s prevstr=""
 f i=1:1 d  i $g(^BigString($zu(86),"stop")) f  h 1000000
 .  s len=$r(length)+1
 .  s str=""
 .  f  q:$l(str)>len  d 
 .  . if Unicode s str=str_$j_$c($r(65536))
 .  . e  s str=str_$j_"*"
 .  s @global=str
 .  s ret=@global
 .  i ret'=str d  q
 .  .  s ^BigString($zu(86),"stop")=$h
 .  .  s ^BigString($zu(86),"job",$j,"expected")=str
 .  .  s ^BigString($zu(86),"job",$j,"actual")=ret
 .  .  s:ret=prevstr ^BigString($zu(86),"job",$j,"same as previous")=1
 .  s totlen=totlen+len
 .  s prevstr=str
 .  i i#100=0 d  h .1
 .  .  s ^BigString($zu(86),"job",$j,"cnt")=i
 .  .  s ^BigString($zu(86),"job",$j,"siz")=^BigString($zu(86),"job",$j,"siz")+totlen
 .  .  s totlen=0
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^BigString($zu(86),"error")=$ze
 g ^%ETN
 q
  

BlockSplit.INT.1.58610,65255.
BlockSplit      ;
 ;
 ; 07/24/97 MDS Revised routine.
 ; 05/31/00 JMB Added test for Unicode and call Unicode data building
 ;                   function if appropriate, else just do ascii.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   Start tag now has an additional parameter that is the
 ;                   number of cluster nodes (default of 1 or not clustered).
 ;                   Because this suite sets a limit on the size of the
 ;                   database, this additional parameter is needed so the
 ;                   calculation could take into account there maybe jobs
 ;                   from different cluster nodes running at the same
 ;                   time.  The other significant change is to add $zu(86)
 ;                   as a subscript to the control global. This is so it
 ;                   can keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "BlockSplit",!
 w "----------",!
 w "BlockSplit stresses the MUMPS global Block Splitting code.  The BlockSplit",!
 w "algorithm is made up of four main steps:",!
 w !
 w "     1) Build a large global of sequential nodes with a loop like:",!
 w "           FOR Count=1:1:SomeNumber SET ^Global(Count)=""""",!
 w "     2) Set the newly created nodes equal to long strings of data:",!
 w "           FOR Count=1:1:SomeNumber SET ^Global(Count)=Big-Data-Sting",!
 w "     3) Insert new nodes between the nodes that already exist:",!
 w "           FOR A=1:1:SomeNumber SET ^Global(A)="""" DO",!
 w "           .FOR B=1:1:10 SET ^Global(A,B)="""" DO",!
 w "           .. FOR C=1:1:10 SET ^Global(A,B,C)="""" DO",!
 w "           ... FOR D=1:1:10 SET ^Global(A,B,C,D)=""""",!
 w "     4) Set the newly created nodes equal to long strings of data:",!
 w "           FOR A=1:1:SomeNumber SET ^Global(A)=Big-Data_Sting DO",!
 w "           .FOR B=1:1:10 SET ^Global(A,B)=Big-Data-String DO",!
 w "           .. FOR C=1:1:10 SET ^Global(A,B,C)=Big-Data-Sting DO",!
 w "           ... FOR D=1:1:10 SET ^Global(A,B,C,D)=Big-Data-Sting",!
 w !
 w "A BlockSplit job only fills up a certain amount of space.  It then kills",!
 w "the Global it is building.  This is done to avoid <FILEFULL> errors.",!
 w "The BlockSplit jobs are each building unique globals.",!
 w !
 w "BSQuery will continously $QUERY through BlockSplit's globals as follows:",!
 w !
 w "          1)  Select a random number for 1 to the number of BlockSplit routines",!
 w "              which are currently running",!
 w "          2)  $QUERY through ^blockSplit# (where # is the random number)",!
 w "          3)  Choose another global (goto step #1)",!
 w !
 w "Please use Start^BlockSplit(splitJobs,queryJobs,length,limit) to start",!
 w "this test.",!
 w "splitJobs = number of block split jobs",!
 w "queryJobs = number of query jobs",!
 w "length    = length of string to store in node",!
 w "limit    = maximum total global storage for all jobs (Mb)",!
 w "The default values will start a minimal meaningful test.",!
 q
  
Start(splitJobs,queryJobs,length,limit,cluster) ; CL
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^BlockSplit($zu(86))) Destroy
 s splitJobs=$g(splitJobs,1)
 s queryJobs=$g(queryJobs,1)
 s length=$g(length,511)
 s limit=$g(limit,10)
 s cluster=$g(cluster,1) ; CL
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With split jobs="_splitJobs_" query jobs="_queryJobs_" length="_length_" limit="_limit)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 n nodes
 s nodes=(limit*1000000)\(1111*length*splitJobs)\cluster ; CL
 s:nodes<1 nodes=1
 s ^BlockSplit($zu(86),"PID")=splitJobs+queryJobs
 s ^BlockSplit("splitJobs")=splitJobs
 f i=1:1:splitJobs j Run("^blockSplit"_i,nodes,length)
 f i=1:1:queryJobs j BSQuery
 q
  
Status() 
 ; Check activity in the CPU for BlockSplit and BSQuery jobs
 q $$Status^Library("1""BlockSplit""",2,15,"^BlockSplit("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops all currently running BlockSplit and BSQuery jobs using their PIDs
 d Stop^Library("^BlockSplit("_$c(34)_$zu(86)_$c(34)_",""PID"")",30)
 q
  
Result() 
 n status
 q:$d(^BlockSplit("error")) "FAIL -- "_^BlockSplit("error")
 q:$d(^BlockSplit)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by ^BlockSplit routine
 n i,max
 i $d(^BlockSplit),$e($$Status,1,17)'="OK -- Not running" d Stop
 s max=$g(^BlockSplit("splitJobs"),50)
 f i=1:1:max k @("^blockSplit"_i)
 k ^BlockSplit
 q
          
Run(G,nodes,length) 
 ; Kills and builds nodes
 s $zt="errorTrap"                            ; Sets error trap
 s Unicode=$$IsUnicode^Library           ; Test for Unicode
 s ^BlockSplit($zu(86),"PID",$J)=""                ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s Data="*" s $P(Data,Data,length)=Data
 f  d
 .  i Unicode d UnicodeData              ; Randomly sets Unicdode characters
 .  d Kill                               ; Kills globals
 .  d Build                              ; Builds sequential nodes
 .  d BigData                            ; Fills nodes with long string
 .  d AddSubs                            ; Adds more nodes in between nodes
 .  d AddBData                           ; Fills nodes with long string
 q
  
UnicodeData 
 s max=length
 s:max>1000 max=1000
 f i=1:1:max s $e(Data,$r(length))=$c($r(65536))
 q
  
Kill 
 f i=1:1 q:'$D(@G@(i))  k @G@(i) 
 q
  
Build  
 f x=1:1:nodes s @G@(x)="" 
 q
  
BigData 
 f x=1:1:nodes s @G@(x)=Data
 q
  
AddSubs 
 f a=1:1:nodes d
 . f b=1:1:10 s @G@(a,b)="" d
 . . f c=1:1:10 s @G@(a,b,c)="" d
 . . . f d=1:1:10 s @G@(a,b,c,d)="" 
 q
  
AddBData 
 f a=1:1:nodes d
 . f b=1:1:10 s @G@(a,b)=Data d
 . . f c=1:1:10 s @G@(a,b,c)=Data d
 . . . f d=1:1:10 s @G@(a,b,c,d)=Data
 q
  
BSQuery 
 ; Continuously $QUERYs through ^blockSplit globals
 s $zt="errorTrap"                    ; Set error trap
 s ^BlockSplit($zu(86),"PID",$J)=""      ; Records job numbers
 n node
 n temp
 f  d
 .  s node="^blockSplit"_$r($g(^BlockSplit("splitJobs"))+1)
 .  s node=$q(@node)
 .  ; Traverse global
 .  f  q:node=""  d
 .  .  s temp=$g(@node)
 .  .  i $d(@node) s node=$q(@node)
 .  .  e  s node=""
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^BlockSplit("error")=$ze
 g ^%ETN
 q
  

Compiler.INT.1.58610,65256.
Compiler                                ; revised by MDS, 7/24/97
 w !
 w "Compiler",!
 w "--------",!
 w "Compiler is a stress test which has a specified number of jobs randomly",!
 w "calling other routines (comp1 through comp10).  Each job will continously",!
 w "edit, compile, and run one of the comp# routines.  Many times, one job will",!
 w "be compiling a routine while another job is running it.  Due to the fact that",!
 w "<NOROUTINE> and <EDITTED> errors are expected, these errors are trapped and",!
 w "execution continues.",!
 w !
 w "Please use Start^Compiler(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value will start a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^Compiler) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^Compiler("PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for Compiler jobs
 q $$Status^Library("1(1""Compiler"",1""comp""1.2N)",2,15,"^Compiler(""PID"")")
  
Stop 
 ; Stops currently running Compiler jobs using their PIDs
 d Stop^Library("^Compiler(""PID"")",15)
 q
  
Result() 
 n status
 q:$d(^Compiler("error")) "FAIL -- "_^Compiler("error")
 q:$d(^Compiler)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS"
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by Compiler routine
 i $d(^Compiler),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^compilerGlobal
 f i=1:1:10 d
 .  k ^ROUTINE("comp"_i)
 .  k ^rOBJ("comp"_i)
 k ^Compiler
 q
         
Run 
 s $zt="errorTrap"                    ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^Compiler("PID",$J)=""        ; Records job numbers
 f  d Create,RunComp
 q
  
Create 
 ; New variables
 n Code,Routine
 ; Need to trap <NOROUTINE> errors
 s $zt="errorTrap"
 ; Do It
 s Code="a s $zt=""errorTrap^Compiler"" k ^compilerGlobal f x=1:1:"_$R(1000)_" s ^compilerGlobal($J)=x"
 s Routine="comp"_($R(10)+1)
 x ("zr  zi Code zs "_Routine)
 q
  
RunComp 
 ; New variables
 n Routine
 ; Trap <NOROUTINE> errors
 s $zt="errorTrap"
 ; Do It
 s Routine="^comp"_($R(10)+1)
 d @Routine
 q
  
errorTrap 
 s $zt="^%ETN"
 i ($ze["<EDITED")!($ze["<NOROUT") q
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^Compiler("error")=$ze
 g ^%ETN
 q
  

DoMany.INT.1.58610,65256.
DoMany ;
 ;
 ; Jobs out a user-specified number of jobs, each of which randomly
 ; DO routines a0 through a99 and b0 through b99.  Routines a0
 ; through a99 and b0 through b99 are the same.
 ;
 ; 07/24/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "DoMany",!
 w "------",!
 w "DoMany is a stress test which has a specified number of jobs randomly calling",!
 w "other routines (^a0 through ^a100 and ^b0 throutgh ^b100).  At one time this",!
 w "test caused M to hang.",!
 w !
 w "Please use Start^DoMany(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value will start a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^DoMany($zu(86),"PID")) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^DoMany($zu(86),"PID")=jobs
 d Create
 f i=1:1:jobs j Run
 q
  
Status() 
 q $$Status^Library("1(1""DoMany"",1(1""a"",1""b"")1.2N)",2,15,"^DoMany("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops currently running DoMany jobs using their PIDs
 d Stop^Library("^DoMany("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
  
Result() 
 n status
 q:$d(^DoMany($zu(86),"error")) "FAIL -- "_^DoMany($zu(86),"error")
 q:$d(^DoMany($zu(86)))=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS"
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 n name,number
 i $d(^DoMany($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^ROUTINE("a")
 k ^rOBJ("a")
 f name="a","b" d
 .  f number=0:1:99 d
 .  .  k ^ROUTINE(name_number)
 .  .  k ^rOBJ(name_number)
 k ^DoMany($zu(86))
 q
  
Run 
 s $zt="errorTrap"                    ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^DoMany($zu(86),"PID",$J)=""         ; Records job numbers
 ; New variables
 n Routine
 ; Perform Test
 f  d
 .  s Routine=$R(100)
 .  d @("^a"_Routine),@("^b"_Routine)
 q
  
Create 
 ; New variables
 n Code                          ; Code to insert into routine
 n RouChar                       ; Routine set - a or b
 n RouNum                        ; Current routine number being created
 ; Initialize Variables
 q:$D(^ROUTINE("b"_99,0,0))
 s Code="a s ^DoMany(""routine"",$J,$zn)=$G(^DoMany(""routine"",$J,$zn))+1"
 ; Create Routines
 x ("zr  zi Code zs a")          ; Create frame routine
 ; Create All Routines
 f RouChar="a","b" d
 .  f RouNum=0:1:99 d
 .  .  x ("zl a zs "_RouChar_RouNum)
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^DoMany($zu(86),"error")=$ze
 g ^%ETN
 q
  

Expand.INT.1.58610,65256.
Expand ;
 ; 11/01/91 DPV Created routine to test MUMPS.DAT creation, expansion
 ;                   and deletion.
 ; 08/04/97 MDS Revised routine.
 ; 05/04/99 LSA Implemented Huayong Yang's suggestion to limit the number of
 ;                   databases created.  The journal directory block (8KB) is
 ;                   not big enough to hold 256 database directory names which
 ;                   can be as long as 256 bytes.  Fixing it would require
 ;                   major revision to the journal system.  In the meantime,
 ;                   the user should keep the database directory names
 ;                   reasonably short (32 bytes or fewer) - if lots of *local*
 ;                   databases are expected while using journaling.  A rule of
 ;                   thumb for the acceptable length of a directory name is to
 ;                   divide 8000 by the number of databases.  In addition,
 ;                   databases cannot be created and deleted forever.  Once a
 ;                   database is created, its sfn (an integer between 0 and 254)
 ;                   is never reused until Cache restarts.  Thus databases can
 ;                   be created only 250+ times at most, regardless of the number
 ;                   of existing databases.
 ;              Added counter for number of databases actually created and fixed
 ;                   value for maximum number of allowable databases.
 ;              Changed quit condition to be when number of databases created exceeds
 ;                   maximum allowable.
 ; 01/30/01 AFH Modified routine for Big Database and fixed a small bug
 ;              1.) Added a parameter to start. You can now optionally pass in the block size of the databases to be created.
 ;                  valid values are 2, 4, 8, 16, 32, 64 for Kb or 2048, 4096, 8192, 16384, 32768, 65536
 ;                  default values non-bigdb system 2k, bigdb system 8k
 ;              2.) Added added syntax to create the database for big db. 
 ;                  $zu(0,dir,blksiz,uic,0,expandby,maxfilsiz,gdir,gpblk,0,0,ggblk,freeze,collation)
 ;              3.) Changed Fill a little to pump in more data for big db - comes closer to filling the dat file in one pass
 ;              4.) a.) Fixed a small bug with stop where it was not quiting the outer loop causing stop to only stop creating .ext's
 ;                      it still created all the .dat's
 ;                  b.) Changed stop so it only stopped from the main loop, it no longer creates partial db's 
 ;                      and ext's. Also removed the call to Delete that was outside the loop. In the normal cases this was
 ;                      redundant. In the case of Stop it was meant to clean up anything left over but could mask errors
 ;                      or give false errors when Stop was not invoked.
 ;              5.) Changed it to create the maximum 7 extents from only 3 extents
 ;              6.) Forced an error if it could not delete the database (only creating 3 extents and not checking the return value of
 ;                  $zu(2) was masking a database delete bug.
 ; 03/22/01 LSA Fixed typo in $zu(27) call of Create3 which prevented 7th extent from
 ;                   being properly created (from Al and found by Carlos)
 ;
 w !
 w "Expand",!
 w "------",!
 w "Expand tests date file creation, expansion and deletion.  It creates an main",!
 w "data file and then adds two extension files, filling each one up as it goes.",!
 w !
 w "Please use Start^Expand(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value will start a minimal meaningful test.",!
 q
Start(jobs,blksiz) 
 s $zt="errorTrap"                               ; Sets error trap
 d:$d(^Expand) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"","Expand Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"","Expand $zu(49)="_$zu(49,""))
 s ^Expand("PID")=jobs
 ;
 ; Set maximum number of databases which can be created 
 ;
 s ^Expand("maxdb")=(8000\($l($zu(12,""))+$l($j)+11))\7\jobs
 ;
 ; Initialize number of databases created
 ; 
 s ^Expand("dbmade")=0
 f i=1:1:jobs j Run($g(blksiz))
 ;f i=1:1:jobs d Run($g(blksiz)) ;debugging
 q
Status() 
 ; Check activity in the CPU for Expand jobs
 q $$Status^Library("1""Expand""",2,15,"^Expand(""PID"")")
Stop 
 n start
 s ^Expand("stop")=""
 s start=$$zh^Library
 f  q:($$zh^Library-start)>15  q:$e($$Status,1,17)="OK -- Not running"
 q
Result() 
 n status,dir
 q:$d(^Expand("error")) "FAIL -- "_^Expand("error")
 q:$d(^Expand)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,2)'="OK" "FAIL -- "_status
 q:$e(status,1,17)'="OK -- Not running" "FAIL -- Jobs are still running."
 s dir=$o(^Expand("UIC",""))
 q:dir'="" "FAIL -- At least one residual database exists."
 q "PASS"
Destroy 
 s $zt="^%ETN"
 n i,dir,delimiter,found,rm,rmdir,mkdir,manager
 i $d(^Expand),$e($$Status,1,17)'="OK -- Not running" d Stop
 d Setup
 ; Pass 1 -- Delete everything known to Expand
 s dir=$o(^Expand("UCI",""))
 f  q:dir=""  d
 .  d Delete(dir)
 .  s dir=$o(^Expand("UCI",dir))
 ; Pass 2 -- Delete everything known to the system.  There probably isn't
 ;           anything left at this point, unless ^Expand is missing.
 s dir=$o(^[manager]SYS("UCI",""))
 s delimiter=$e(dir,$l(dir))
 f  q:dir=""  d
 .  d:$p(dir,delimiter,$l(dir,delimiter)-1)?1"expand"3.N Delete(dir)
 .  s dir=$o(^[manager]SYS("UCI",dir))
 k ^Expand
 q
Run(blksiz) 
 s $zt="zBitTrap"
 s bigdb=$$zBitGet^Library(21)
 i bigdb,'$g(blksiz) s blksiz=8192
 i bigdb,blksiz<65 s blksiz=blksiz*1024
 i bigdb s expandby=$s(blksiz=2048:400,blksiz=4096:256,1:128),maxflsiz=$s(blksiz=2048:800,blksiz=4096:256,1:128)
 i 'bigdb s blksiz=400
 s $zt="errorTrap"                               ; Sets error trap
 s ^Expand("PID",$j)=""                          ; Records job number
 i $zu(9,"","Expand Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 n Dir,Dir2,Dir3,index
 n rm,rmdir,mkdir,manager
 d Setup
 ;f i=1:1 q:$d(^Expand("stop"))  d
 ;
 ; Quit when maximum number of databases have been created 
 ; 
 f i=1:1 q:(^Expand("dbmade")>(^Expand("maxdb")-1))  q:$d(^Expand("stop"))  d
 .  s index=0
 .  d Create
 .  d Fill
 .  f ext="Two","Three","Four","Five","Six" d
 ..  d Create2
 ..  d Fill
 .  d Create3
 .  d FillUp
 .  d Delete(Dir)
 ;d Delete(Dir) ; commented out AFH
 l ^Expand("PID")
 k ^Expand("PID",$j)
 s ^Expand("PID")=$g(^Expand("PID"))-1
 i $zu(9,"","Expand Job "_$j_" Finished at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 q
Create 
 ;
 ; Increment number of databases created
 ; 
 s ^Expand("dbmade")=^Expand("dbmade")+1
 ; Create a directory (if necessary) and then creates MUMPS.DAT with one map
 n temp
 s Dir="expand"_$j_$p($h,",",2)
 s temp=$zf(-1,mkdir_Dir)
 i temp#65536'=success s $ze="Failed to create directory." g errorTrap
 s Dir=$zu(12,Dir)
 ; Coment from edzu.c on how to use $zu(0):
 ;   $zu(0,dirname,blks/map,uic,# maps,expand by,max size,
 ;   global dir, global ptr,routine dir, routine growth,
 ;   global growth)
 i bigdb s temp=$zu(27,Dir,Dir,blksiz,1,"") s temp=$zu(0,Dir,blksiz,0,0,expandby,maxflsiz,0,16,0,0,50,2,5)
 e  s temp=$zu(0,Dir,400,0,1,1,1,4,5,6,7,8)
 i temp'=1 s $ze="Failed to create database." g errorTrap
 s temp=$zu(17,Dir)
 i temp=-1 s $ze="Failed to mount database." g errorTrap
 s ^[manager]SYS("UCI",Dir)=""
 s ^Expand("UCI",Dir)=""
 q
Create2 
 ; Create a directory and secondary volume for the previously created directory
 n zu27,temp
 s Dir2=Dir_ext
 s temp=$zf(-1,mkdir_Dir2)
 i temp#65536'=success s $ze="Failed to create directory." g errorTrap
 s Dir2=$zu(12,Dir2)
 s zu27=$zu(27,Dir2,Dir,blksiz,1)
 s ^[manager]SYS("UCI",Dir,$p(zu27,"^",3))=$p(zu27,"^",1)
 s ^[manager]SYS("UCI",$p(zu27,"^"))=Dir
 q
Create3 
 ; Create a directory and third volume for the previously created directory
 n zu27,temp
 s Dir3=Dir_"Seven"
 s temp=$zf(-1,mkdir_Dir3)
 i temp#65536'=success s $ze="Failed to create directory." g errorTrap
 s Dir3=$zu(12,Dir3)
 s zu27=$zu(27,Dir3,Dir,blksiz,1)
 s ^[manager]SYS("UCI",Dir,$p(zu27,"^",3))=$p(zu27,"^",1)
 s ^[manager]SYS("UCI",$p(zu27,"^"))=Dir
 q
Fill 
 ; Fill up the database
 s $zt="errorTrap"
 n nodes,base
 s bigdb=$$zBitGet^Library(21)
 s base=$s(bigdb:930,1:750)
 s nodes=base+$r(100)  ; Play with the boundary.  Between 750 and 800 nodes fill up one .dat file.
 f index=(index+1):1:(index+nodes) s $p(^[("^^"_Dir)]Filler(index),"*",500)=index
 q
FillUp 
 ; Fill up the database
 s $zt="errorTrap"
 f index=(index+1):1 s $p(^[("^^"_Dir)]Filler(index),"*",500)=index
 q
Delete(dir) 
 ; Delete a database and all extensions
 n dir2,dir3,temp,delimiter
 s delimiter=$e(dir,$l(dir))
 s dir2=dir_"Two"_delimiter
 s dir3=dir_"Three"_delimiter
 s dir4=dir_"Four"_delimiter
 s dir5=dir_"Five"_delimiter
 s dir6=dir_"Six"_delimiter
 s dir7=dir_"Seven"_delimiter
 s temp=$zu(17,dir)  ; Mount it (if not already)
 s temp=$zu(2,dir)   ; Kill it
 i temp'=1 s $ze="Failed to delete database." g errorTrap
 k ^["%SYS"]SYS("UCI",dir2)
 k ^["%SYS"]SYS("UCI",dir3)
 k ^["%SYS"]SYS("UCI",dir4)
 k ^["%SYS"]SYS("UCI",dir5)
 k ^["%SYS"]SYS("UCI",dir6)
 k ^["%SYS"]SYS("UCI",dir7)
 k ^["%SYS"]SYS("UCI",dir)
 ; We delete all the files, even though $zu(2) theoretically does it for us.
 ; This way, if $zu(2) is broken, the files still get deleted (maybe).
 ; Note also that since we use an explicit DB name (which changes about once
 ; a year) this code is highly breakable.  If there is a mechanism to
 ; introspect the DB file name, use it!
 s temp=$zf(-1,rm_dir2_"CACHE.EXT")
 s temp=$zf(-1,rmdir_$e(dir2,1,$l(dir2)-1))
 s temp=$zf(-1,rm_dir3_"CACHE.EXT")
 s temp=$zf(-1,rmdir_$e(dir3,1,$l(dir3)-1))
 s temp=$zf(-1,rm_dir4_"CACHE.EXT")
 s temp=$zf(-1,rmdir_$e(dir4,1,$l(dir4)-1))
 s temp=$zf(-1,rm_dir5_"CACHE.EXT")
 s temp=$zf(-1,rmdir_$e(dir5,1,$l(dir5)-1))
 s temp=$zf(-1,rm_dir6_"CACHE.EXT")
 s temp=$zf(-1,rmdir_$e(dir6,1,$l(dir6)-1))
 s temp=$zf(-1,rm_dir7_"CACHE.EXT")
 s temp=$zf(-1,rmdir_$e(dir7,1,$l(dir7)-1))
 s temp=$zf(-1,rm_dir_"CACHE.DAT")
 s temp=$zf(-1,rmdir_$e(dir,1,$l(dir)-1))
 k ^Expand("UCI",dir)
 q
Setup 
 d ^%ST
 d:%ST["UX"
 .  s rm="rm "
 .  s rmdir="rmdir "
 .  s mkdir="mkdir "
 .  s success=0
 d:%ST["WNT"
 .  s rm="rm "
 .  s rmdir="rmdir "
 .  s mkdir="mkdir "
 .  s success=0
 d:%ST["AV"
 .  s rm="DELETE "
 .  s rmdir="DELETE "
 .  s mkdir="CREATE/DIRECTORY "
 .  s success=1
 s manager=$g(%ST("MGRNSP"),"^^"_$g(%ST("MGDIR")))
 q
errorTrap 
 s $zt="^%ETN"
 q:$ze["<FILE"
 i $zu(9,"","Expand Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ZR=$ZR
 s ^Expand("error")=$ze
 g ^%ETN
 q
zBitTrap ;
 i $ze["<FUNCTION" s bigdb=0 q
 i $zu(9,"","Expand Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ZR=$ZR
 s ^Expand("error")=$ze
 g ^%ETN
 q
 

Exponent.INT.1.58610,65256.
Exponent                                 ; revised by MDS, 8/7/97
 ; Written by Stephanie Li, 3/7/91
 w !
 w "Exponent",!
 w "--------",!
 w "This program is for exponential notation tests.  It tests exponential",!
 w "notation. The operators are addition, subtraction, multiplication, division,",!
 w "integer division and modulo.  To determine whether exponential notation test",!
 w "works properly, it compares two results. For the actual result, a number in",!
 w "exponential notation is used For the expected result, a multiplied number",!
 w "is used.  The results are evaluated by applying above operators.",!
 w !
 w "For example:",!
 w "1E2*2 = 1*10*10*2",!
 w "If they are different, it should be a bug.",!
 w !
 w "Please use Start^Exponent(jobs,precision) to start this test.",!
 w "jobs      = the number of jobs to start",!
 w "precision = the number of significant figures to test (default = 15)",!
 w "The default values will start a minimal meaningful test.",!
 q
  
Start(jobs,precision) 
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^Exponent) Destroy
 s jobs=$g(jobs,1)
 s precision=$g(precision,15)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs_" precision="_precision)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^Exponent("precision")=precision
 s ^Exponent("log","+","error")=0
 s ^Exponent("log","-","error")=0
 s ^Exponent("log","*","error")=0
 s ^Exponent("log","/","error")=0
 s ^Exponent("log","\","error")=0
 s ^Exponent("log","#","error")=0
 s ^Exponent("PID")=jobs
 f i=1:1:jobs j Run(precision)
 q
  
Status() 
 ; Check activity in the CPU for Exponent jobs
 q $$Status^Library("1""Exponent""",2,15,"^Exponent(""PID"")")
  
Stop 
 n start
 s ^Exponent("stop")=""
 s start=$$zh^Library
 f  q:($$zh^Library-start)>15  q:$e($$Status,1,17)="OK -- Not running"
 q
  
Result() 
 n result,i,error,CRLF,precision,width,line,fail,status,operation
 q:$d(^Exponent("error")) "FAIL -- "_^Exponent("error")
 q:$d(^Exponent)=0 "FAIL -- Test data are missing."
 ; Report on degree of error, if any
 s CRLF=$c(13,10)
 s fail=0
 s precision=$g(^Exponent("precision"))+1
 s width=precision+2
 s:width<14 width=14
 ; Creat heading
 s result="Operation "_$j("Largest Error",width)_CRLF
 s line=""
 s $p(line,"-",$l(result)-2)="-"
 s result=result_line_CRLF
 ; Scan thru log
 s operation=$o(^Exponent("log",""))
 f  q:operation=""  d
 .  s result=result_operation_$j(" ",9)
 .  s error=^Exponent("log",operation,"error")
 .  s result=result_$j(error,width,precision)_CRLF
 .  s:error fail=1
 .  s operation=$o(^Exponent("log",operation))
 ; Finish up
 q:fail result_"FAIL"
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" result_"PASS"
 q:$e(status,1,2)="OK" result_"FAIL -- Still running."
 q result_"FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by ^Exponent routine
 i $d(^Exponent),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^Exponent
 q
  
Run(sig) 
 s $zt="errorTrap"                       ; Sets error trap
 s ^Exponent("PID",$j)=""         ; Records job number
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 f i=1.5:200.5 q:$d(^Exponent("stop"))  d
 .  f j=0:2:6 q:$d(^Exponent("stop"))  d
 .  .  s exp2=1
 .  .  f l=1:1:j s exp2=exp2*10
 .  .  f k=1.5:200.5:1000 q:$d(^Exponent("stop"))  d
 .  .  .  s expect=exp2*i
 .  .  .  d Addition q:$d(^Exponent("stop"))
 .  .  .  d Subtraction q:$d(^Exponent("stop"))
 .  .  .  d Multiplication q:$d(^Exponent("stop"))
 .  .  .  d Division q:$d(^Exponent("stop"))
 .  .  .  d IntegerDivision q:$d(^Exponent("stop"))
 .  .  .  d Modulo q:$d(^Exponent("stop"))
 k ^Exponent("PID",$j)
 l ^Exponent("PID")
 s ^Exponent("PID")=$g(^Exponent("PID"))-1
 q
         
Addition 
 s expA1=k_"+"_i_"E"_j_"+"_k
 s aexpect=k+expect+k
 s aexpect=$$truncate(aexpect,sig)
 x "s aans="_expA1
 s aans=$$truncate(aans,sig)
 i (aexpect'=aans) d LogError("+",expA1,aexpect,aans)
 q
  
Subtraction 
 s expS1=i_"E"_j_"-"_k
 s sexpect=$$truncate(expect-k,sig)
 x "s sans="_expS1
 s sans=$$truncate(sans,sig)
 i (sexpect'=sans) d LogError("-",expS1,sexpect,sans)
 q
  
Multiplication 
 s expMU1=i_"E"_j_"*"_k
 s muexpect=$$truncate(expect*k,sig)
 x "s muans="_expMU1
 s muans=$$truncate(muans,sig)
 i (muexpect'=muans) d LogError("*",expMU1,muexpect,muans)
 q
  
Division 
 s expD1=i_"E"_j_"/"_k
 s dexpect=$$truncate(expect/k,sig)
 x "s dans="_expD1
 s dans=$$truncate(dans,sig)
 i (dexpect'=dans) d LogError("/",expD1,dexpect,dans)
 q
  
IntegerDivision 
 s expID1=i_"E"_j_"\"_k
 s idexpect=$$truncate(expect\k,sig)
 x "s idans="_expID1
 s idans=$$truncate(idans,sig)
 i (idexpect'=idans) d LogError("\",expID1,idexpect,idans)
 q
  
Modulo 
 s expM1=i_"E"_j_"#"_k
 s mexpect=$$truncate(expect#k,sig)
 x "s mans="_expM1         
 s mans=$$truncate(mans,sig)
 i (mexpect'=mans) d LogError("#",expM1,mexpect,mans)
 q
  
truncate(x,y) 
 s decimal=$p(x,".",2)
 s num=0
 i (decimal="") q x
 f o=1:1 s num=num+1 q:$e(decimal,o)'="0"
 s num=num-1
 s len=$l(decimal)-num
 i len>y s $p(x,".",2)=$e($p(x,".",2),1,num+y) q x
 q x
  
LogError(operation,expression,expected,actual) 
 n error
 s error=$zabs(expected-actual)
 l ^Exponent("log")
 d:^Exponent("log",operation,"error")<error
 .  s ^Exponent("log",operation,"error")=error
 .  s ^Exponent("log",operation,"expression")=expression
 .  s ^Exponent("log",operation,"expected")=expected
 .  s ^Exponent("log",operation,"actual")=actual
 l
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^Exponent("error")=$ze
 g ^%ETN
  
  

GMash.INT.1.58610,65256.
GMash ;
 ;
 ; 07/24/97 MDS Revised routine.
 ; 05/04/99 LSA Added Simon Li's fix to test unicode compaction.  The lines
 ;                   removed are marked ;SMLXXX- and the lines inserted are
 ;                   marked ;SMLXXX+ after the code.  The content of the
 ;                   global data is also checked instead of just getting the
 ;                   length of the global data.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   Start tag now has an additional parameter that is the
 ;                   number of cluster nodes (default of 1 or not clustered).
 ;                   Because this suite sets a limit on the size of the
 ;                   database, this additional parameter is needed so the
 ;                   calculation could take into account there maybe jobs
 ;                   from different cluster nodes running at the same
 ;                   time.  The other significant change is to add $zu(86)
 ;                   as a subscript to the control global. This is so it
 ;                   can keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;         
 w !
 w "GMash",!
 w "-----",!
 w "GMash was originally written by IDX Corporation and used to cause database",!
 w "degradation.  GMash stresses the global module and builds very large globals.",!
 w !
 w "Please use Start^GMash(jobs,limit) to start this test.",!
 w "jobs  = number of jobs to start                        (default = 1)",!
 w "limit = maximum total global storage for all jobs (Mb) (default = 10)",!
 w "The default values will start a minimal meaningful test.",!
 q
Start(jobs,limit,cluster) ;AFH   
 ; Starts up GMash jobs
 s $zt="errorTrap"                    ; Sets error trap
 set jobs=$get(jobs,1),cluster=$get(cluster,1)
 s:'$g(jobs) jobs=1 k:'$g(limit) limit ;AFH
 s limit=$g(limit,10)*1000000\jobs\cluster
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs_" Limit="_limit)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 d:$d(^GMash($zu(86))) Destroy
 s ^GMash($zu(86),"jobs")=jobs
 s ^GMash($zu(86),"PID")=jobs
 f i=1:1:jobs j Run(limit)
 q
Status() 
 ; Check activity in the CPU for GMash jobs
 q $$Status^Library("1""GMash""",2,15,"^GMash("_$c(34)_$zu(86)_$c(34)_",""PID"")")
Stop 
 ; Stops currently running GMash jobs using their PIDs
 d Stop^Library("^GMash("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
Result() 
 n status
 q:$d(^GMash("error")) "FAIL -- "_^GMash("error")
 q:$d(^GMash)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
Destroy ; Kills ^GMash global
 n max
 if $data(^GMash),$extract($$Status,1,17)'="OK -- Not running" do Stop
 k ^gmash
 k ^GMash
 q
Run(limit) 
 ; Perform test
 s $zt="errorTrap"                    ; Sets error trap
 s ^GMash($zu(86),"PID",$J)=""           ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s G="^gmash"
 s Span=5000
 s String="the quick brown fox jumped over the lazy dog "
 s MaxKeyLen=215
 s Size=32767
 s Str=""
 ;f  s Str=Str_String q:(Size-$L(Str))<$L(String)  ;SMLXXX-
 l +^GMash("currentjob")  ;SMLXXX+
 s cj=$g(^GMash("currentjob"),0)+1,^GMash("currentjob")=cj  ;SMLXXX+
 l -^GMash("currentjob")  ;SMLXXX+
 i cj#2=0 f  s Str=Str_String q:(Size-$L(Str))<$L(String)  ;SMLXXX+
 ;put unicode character in the string
 i cj#2 f i=1:1:Size s Str=Str_$s($r(4)=0:$c(2222),1:$c($a("A")+$r(26))) ;SMLXXX+
 s load=0
 f  d
 .  s a=$R(Span)
 .  s b=$R(Span)
 .  s c=$R(Size)
 .  s s=a+b
 .  d @($r(10)+1)
 .  d:load>limit
 .  .  k @G@($j)
 .  .  s load=0
 q
1 f i=a:1:s q:load>limit  d SetNode(i,c)
 q
2 f i=a:1:s d KillNode(i)
 q
3 f i=a:1:s d CheckNode(i)
 q
4 f i=s:-1:a q:load>limit  d SetNode(i,c)
 q
5 f i=s:-1:a d KillNode(i)
 q
6 f i=s:-1:a d CheckNode(i)
 q
7 s x=$J(a,5)
 f i=1:1:b d
 .  s x=$O(@G@($J,x))
 .  ;i x'="",$D(^(x))#2,$L(^(x))  ;SMLXXX-
 .  ; check if gets correct data
 .  i x'="",$D(^(x))#2,$$chkdata(^(x))  ;SMLXXX+
 q
8 f i=1:1:a q:load>limit  d
 .  s a1=$R(Span)
 .  s a2=$R(100)+1
 .  s a3=$R(Size)
 .  s data=$E(Str,1,a3)
 .  ;s @G@($J,$J(a1,5),$E(Str,1,a2))=data  ;SMLXXX-
 .  ; put length at beginning of the string
 .  s @G@($J,$J(a1,5),$E(Str,1,a2))=$$getdata(data)  ;SMLXXX+
 .  s load=load+5+a2+$l(data)
 q
9 f i=1:1:a d
 .  s node=$J($R(Span),5)
 .  ; we should check top node
 .  i $d(@G@($j,node))#2 s load=load-5-$$chkdata(@G@($j,node)) ;SMLXXX+
 .  s n=$o(@G@($j,node,""))
 .  f  q:n=""  d
 .  .  ;s load=load-5-$l(n)-$l(@G@($j,node,n))  ;SMLXXX-
 .  .  ;check correct data with length at beginning of the string
 .  .  s load=load-5-$l(n)-$$chkdata(@G@($j,node,n))  ;SMLXXX+
 .  .  s n=$o(@G@($j,node,n))
 .  k @G@($J,node)
 q
10 s d=$R(100)
 s e=$R(100)
 f i=1:1:d d
 .  s a1=$R(Span)
 .  s x=$J(a1,5)
 .  ;s y=$D(@G@($J,x)) i y#2,$L(^(x))  ;SMLXXX-
 .  ;check correct data with length at beginning of the string
 .  s y=$D(@G@($J,x)) i y#2,$$chkdata(^(x))  ;SMLXXX+
 .  s x=$O(^(x,""))
 .  i x'="",y<10 s errnam="get2_a",errmsg="x="_x_",$D="_y
 .  i x="",y'<10 s errnam="get2_b",errmsg="x="_x_",$D="_y
 .  s x=""
 .  ;f j=1:1:e s x=$O(^(x)) q:x=""  i $L(^(x))  ;SMLXXX-
 .  ;check correct data with length at beginning of the string
 .  f j=1:1:e s x=$O(^(x)) q:x=""  i $$chkdata(^(x))  ;SMLXXX+
 q
SetNode(index,size) 
 s node=$J(index#Span,5)_$E(Str,1,$R(MaxKeyLen-15))
 ;s @G@($J,node)=$E(Str,1,size)  ;SMLXXX-
 ; put length at beginning of the string
 s @G@($J,node)=$$getdata($E(Str,1,$r(1000)))  ;SMLXXX+, AFH
 s load=load+$l(node)+$l(@G@($J,node))
 q
KillNode(index) 
 s node=$J(index#Span,5)_$E(Str,1,$R(MaxKeyLen-15))
 ;s:$d(@G@($J,node)) load=load-$l(node)-$l($g(@G@($J,node)))  ;SMLXXX-
 ; check the data is being killed
 s:$d(@G@($J,node)) load=load-$l(node)-$$chkdata($g(@G@($J,node)))  ;SMLXXX+
 k @G@($J,node)
 q
CheckNode(index) 
 s node=$J(index#Span,5)_$E(Str,1,$R(MaxKeyLen-15))
 ;i $D(@G@($J,node))#2,$L(^(node))  ;SMLXXX-
 ;check correct data with length at beginning of the string
 i $D(@G@($J,node))#2,$$chkdata(^(node))  ;SMLXXX+
 q
 ;SMLXXX+, add getdata() to prepand length at beginning of the string
 ; the string length remain the same.        
getdata(datax) 
 q $s($l(datax)=0:"",$l(datax)=1:"1",1:$l(datax)_","_$e(datax,1,$l(datax)-$l($l(datax))-1))
 ;SMLXXX+, add chkdata() to compare the string passed in is correct by checking
 ; the length at beginning of the string.
chkdata(datac) 
 n dl s dl=$l(datac) q:dl=0 dl i dl=1 q:datac="1" dl ZT "DATA NOT MATCH1"
 i datac'=$$getdata($e(Str,1,$l(datac))) ZT "DATA NOT MATCH"
 q dl
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^GMash("error")=$ze
 g ^%ETN
 q

GlobalName.INT.1.58610,65256.
GlobalName ;
 ;
 ; Stresses the Write Daemon and Global Directory integrity
 ;
 ; 07/24/97 MDS Revised routine.
 ; 05/04/99 LSA Added Carlos Lopes' fix for <UNDEFINED> characters.  A global
 ;                   name is created as '^' + random character + lowercase + 
 ;                   numeric[0-4] and then sets/kills are attempted on this
 ;                   global.  There's an error trap to handle <SYNTAX> and
 ;                   <WIDE CHAR> errors and to remove the offending character
 ;                   from the list of available characters.  However, if this
 ;                   character is '|', you get a <UNDEFINED> error which is not
 ;                   handled.  The process dies (leaving a record in ^%ER) and
 ;                   probably reports a failure.  The commands Set G="^|a0" and
 ;                   Set @G@(1)="Hello" will show that '|' is undefined.  The fix
 ;                   is to add <UNDEFINED> to the list of handled errors.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   Start tag now has an additional parameter that is the
 ;                   number of cluster nodes (default of 1 or not clustered).
 ;                   Because this suite sets a limit on the size of the
 ;                   database, this additional parameter is needed so the
 ;                   calculation could take into account there maybe jobs
 ;                   from different cluster nodes running at the same
 ;                   time.  The other significant change is to add $zu(86)
 ;                   as a subscript to the control global. This is so it
 ;                   can keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.       
 ;
 w !
 w "GlobalName",!
 w "----------",!
 w "GlobalName starts a user defined number of jobs which continously do",!
 w "the following:",!
 w !
 w "         50% - SET a random global",!
 w "         40% - KILL content of a random global, but leave global in directory",!
 w "         10% - KILL a whole random global",!
 w !
 w "GlobalName generates globals of the following form:",!
 w !
 w "         <lowercase letter>_<unicode character>_<0-4>",!
 w !
 w "Please use Start^GlobalName(jobs,limit) to start this test.",!
 w "jobs  = number of jobs to start",!
 w "limit = maximum number of different unicode characters that a job may have in",!
 w "        use at one time.",!
 w "The default value will start a minimal meaningful test.",!
 q
  
Start(jobs,limit,cluster) ; CL
 ; Starts up GlobalName jobs
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^GlobalName($zu(86))) Destroy
 s jobs=$g(jobs,1)
 s cluster=$g(cluster,1) ; CL
 s limit=$g(limit,26)\cluster    ; CL
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs_" Limit="_limit)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^GlobalName($zu(86),"PID")=jobs+1
 j fillAccept
 f  q:$$UnicodeLength^Library("^GlobalName(""accept"")")>96
 f i=1:1:jobs j Run(limit)
 q
  
Status() 
 q $$Status^Library("1(1""GlobalName"",1""Library"")",2,15,"^GlobalName("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops currently running GlobalName jobs using their PIDs
 d Stop^Library("^GlobalName("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
  
Result() 
 n status,result,node,last
 q:$d(^GlobalName("error")) "FAIL -- "_^GlobalName("error")
 q:$d(^GlobalName)=0 "FAIL -- Test data are missing."
 s result=""
 s accept="^GlobalName(""accept"")"
 d:$d(@accept)
 .  s result="The following characters were disallowed in global names:"_$c(13,10)
 .  s length=$$UnicodeLength^Library(accept)
 .  s last=-1
 .  s comma=""
 .  f i=1:1:length q:$l(result)>30000  d
 .  .  s current=$a($$UnicodeFetch^Library(accept,i))
 .  .  d:current-last>1
 .  .  .  s result=result_comma_(last+1)
 .  .  .  s:current-last>2 result=result_"-"_(current-1)
 .  .  .  s comma=", "
 .  .  s last=current
 .  i $l(result)'>30000,last<65535 d
 .  .  s:last=65534 result=result_comma_"65535"
 .  .  s:last<65534 result=result_comma_(last+1)_"-65535"
 .  s result=result_$c(13,10)
 .  s:$l(result)>30002 result=result_"Did not show all ranges.  Query ^GlobalName(""accept"") for a complete list."_$c(13,10)
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" result_"PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" result_"FAIL -- Still running."
 q result_"FAIL -- "_status
  
Destroy ; Kills ^GlobalName global
 i $d(^GlobalName),$e($$Status,1,17)'="OK -- Not running" d Stop
 n node
 d Fetch^%GD("*",1,0)
 s node=$o(^%utility($j,""))
 f  q:node=""  d
 .  k:node?1"^"2E1N @node
 .  s node=$o(^%utility($j,node))
 k ^GlobalName
 q
  
Run(limit) 
 s $zt="errorTrap"
 s ^GlobalName($zu(86),"PID",$j)=""   ; Record job number
 s accept="^GlobalName(""accept"")"
 s $etrap="g RunTrap"
 ;write message to cconsole.log
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 f  d
 .  ; Select a list of characters to test
 .  f index=1:1:limit s map(index)=$c($r(65536))
 .  ; Test them
 .  f test=1:1:10000 d
 .  .  s index=$r(limit)+1
 .  .  s character=map(index)
 .  .  s G="^"_$c($r(26)+97)_character_$r(5)
 .  .  s:($r(2)=1)&($a(character)>96) G="^"_character_$c($r(26)+97)_$r(5)
 .  .  i (test#10)=0 k @G q                       ; 10% of the time KILL the whole global
 .  .  i (test#2)=0 k @G@(1) q                    ; 40% of the time KILL the global but leave the directory entry
 .  .  i (test#2)=1 f i=1:1:$r(20) s @G@(1,i)=$j  ; 50% of the time SET nodes in the global
 .  ; Clean up mess, so we can choose another set of characters
 .  f i=97:1:122 d
 .  .  f index=1:1:limit d
 .  .  .  s character=map(index)
 .  .  .  s G="^"_$c(i)_character
 .  .  .  f j=0:1:4 k @(G_j)
 .  .  .  q:$a(character)<97
 .  .  .  s G="^"_character_$c(i)
 .  .  .  f j=0:1:4 k @(G_j)
 q
RunTrap 
 s $ecode=""         ; Clear ANSI-style error condition
 i ($ze["<SYNTAX>")!($ze["<WIDE CHAR>")!($ze["<UNDEFINED>") d  q
 .  l @accept
 .  d UnicodeRemove^Library(accept,character)
 .  l
 .  s map(index)=$$UnicodeFetch^Library(accept,$r($$UnicodeLength^Library(accept))+1)
 g errorTrap
 q
  
fillAccept 
 s ^GlobalName($zu(86),"PID",$j)=""
 s accept="^GlobalName(""accept"")"
 f i=0:1:65535 d
 .  l @accept
 .  d UnicodeAdd^Library(accept,$c(i))
 .  l
 l ^GlobalName($zu(86),"PID")
 k ^GlobalName($zu(86),"PID",$j)
 s ^GlobalName($zu(86),"PID")=$g(^GlobalName($zu(86),"PID"))-1
 q
  
errorTrap 
 s $zt="^%ETN"
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ZR=$ZR
 s ^GlobalName("error")=$ze
 g ^%ETN
 q
  

IPC.INT.1.58610,65256.
IPC                             ; revised by MDS, 8/4/97
 w !
 w "IPC",!
 w "---",!
 w "IPC is a test which stresses the Interprocess Communication code.",!
 w "IPC starts a user specified number of jobs in the background, each",!
 w "of which will continually OPEN, USE, READ or WRITE, and CLOSE a random",!
 w "process.",!
 w !
 w "Please use Start^IPC(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value will start a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^IPC) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^IPC("PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for IPC jobs
 q $$Status^Library("1""IPC""",2,15,"^IPC(""PID"")")
  
Stop 
 ; Stops all currently running IPC jobs using their PIDs
 d Stop^Library("^IPC(""PID"")",30)
 q
  
Result() 
 n status
 q:$d(^IPC("error")) "FAIL -- "_^IPC("error")
 q:$d(^IPC)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS"
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by ^IPC routine
 i $d(^IPC),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^IPC
 q
  
Run 
 s $zt="errorTrap"                       ; Sets error trap
 s ^IPC("PID",$J)=""                 ; Records job numbers
 ;write message to cconsole.log
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 ; New Variables
 n command,toggle
 d BuildCommandMappings
 f  d
 .  s toggle=$r(2)
 .  d:toggle Proc($r(command))
 .  d:'toggle OutPut
 q
  
BuildCommandMappings 
 ; command contains platform specific os commands to call.  It has the
 ; following format:
 ;    command = number of commands.  Only includes command(#) nodes.
 ;    command(#) = the remaining platform specific commands
 ;    command("cat") = command to pipe keyboard input to a file
 ;    command("rm")  = command to delete a file
 d ^%ST
 d:%ST["UX"
 .  s command=6
 .  s command("cat")=$$WhereIs("cat")_">"
 .  s command("rm")="rm"
 .  s command(0)=$$WhereIs("who")
 .  s command(1)=$$WhereIs("ls")
 .  s command(2)=$$WhereIs("pwd")
 .  s command(3)=$$WhereIs("date")
 .  s command(4)=$$WhereIs("df")
 .  s command(5)=$$WhereIs("ps")
 d:%ST["WNT"
 .  s command=4
 .  s command("cat")=""  ; The write test is currently disabled because writing to pipes doesn't work in the NT product yet.
 .  s command("rm")="del"
 .  s command(0)="dir"
 .  s command(1)="arp -a"
 .  s command(2)="netstat"
 .  s command(3)="vol"
 d:%ST["AV"
 .  s command=0   ; We need to come up with some stuff for VMS.
 q
  
WhereIs(Proc)   ; Unix specific path finder.
 ; New Variable
 n TmpFile                       ; Temporary file
 n WhereIs                       ; Path name to file
 ; Initialize Variables
 s TmpFile="whereis."_$j
 ; Put path name in file
 i $zf(-1,"whereis "_Proc_" > "_TmpFile)
 ; Extract information from TmpFile
 o TmpFile:"R":10 e  q ""
 u TmpFile
 r WhereIs
 c TmpFile
 i $zf(-1,"rm "_TmpFile)
 q $p(WhereIs," ",2)
  
Proc(Num) 
 ; New Variables
 n Line                          ; Array to store data in
 n ProcName                      ; Full path name to unix procedure
 ; Initialize Variables
 s $zt="EOF"
 s ProcName=command(Num)
 q:ProcName=""
 ; Open Device
 o ProcName:"QR":10 e  q        ; Could not OPEN this process
 u ProcName                     ; Use device
 ; Read Data
 f LineNum=1:1 d
 .  r Line(LineNum)
EOF 
 s $zt="errorTrap"
 g:$ze'["<END" errorTrap
 s ^IPC("command",ProcName)=$g(^IPC("command",ProcName))+1
 c ProcName
 q
  
OutPut 
 ; New Variables
 n catCall                       ; Full path to Unix cat command
 n File                          ; File to output to
 n Array
 ; Initialize Variables
 q:$g(command("cat"))=""
 s File="IPC"_$j
 s catCall=command("cat")_" "_File
 ; Open File and do our stuff
 o catCall:"QW":10 e  q
 d BldArray,WrtArray
 ; Clean up
 c catCall
 d ChkFile
 q
  
BldArray 
 ; Create Array
 f Index=1:1:100 s Array(Index)=Index_$h_$h_$h_$h_$h_$h_$h
 q
  
WrtArray 
 ; Write Array
 u catCall
 f Index=1:1:100 w Array(Index),!
 q
  
ChkFile 
 ; New Variables
 n Data                                  ; Data read from file to compare with array
 ; Open File
 o File:"R":10
 e  s $ze="<NOTOPEN> ChkFile^IPC" g errorTrap
 u File
 ; Perform verify
 f Index=1:1:100 d
 .  r Data
 .  i Data'=Array(Index) s $ze="<PIPE PROBLEM> ChkFile^IPC" g errorTrap
 ; Clean up
 c File
 i $zf(-1,command("rm")_" "_File)
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^IPC("error")=$ze
 g ^%ETN
 q
  
  

Interlock.INT.1.58610,65256.
Interlock                                ; revised by MDS, 7/24/97
 w !
 w "Interlock",!
 w "---------",!
 w "Interlock is a test which stresses the M Routine Interlocking code.  The",!
 w "test starts a device code.  Starts a user specified number of jobs",!
 w "in the background, each of which are LOCKing various Routine Interlock",!
 w "devices.  Checks for Routine Interlocking devices being OPENed by",!
 w "more than one process at a time.  Therefore, this test is only meaningful",!
 w "if you run at least two jobs.",!
 w !
 w "Please use Start^Interlock(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value will start a minimal meaningful test (2 jobs).",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^Interlock) Destroy
 s jobs=$g(jobs,2)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^Interlock("PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for Interlock jobs
 q $$Status^Library("1""Interlock""",2,15,"^Interlock(""PID"")")
  
Stop 
 ; Stops currently running Interlock jobs using their PIDs
 d Stop^Library("^Interlock(""PID"")",15)
 q
  
Result() 
 n status
 q:$d(^Interlock("error")) "FAIL -- "_^Interlock("error")
 q:$d(^Interlock)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS"
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by Interlock routine
 i $d(^Interlock),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^Interlock
 q
  
Run 
 s $zt="errorTrap"                    ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^Interlock("PID",$J)=""        ; Records job numbers
 ; New variables
 n G                             ; Global reference (path to ^RID)
 n Device                        ; Routine Interlock device to use
 n Result                        ; Result of open command
 ; Initialize variables
 s G="^Interlock(""device"")"
 ; Perform test
 f  d
 .  i $R(2) s Device=$R(27)+20
 .  e  s Device=$R(24)+200
 .  o Device::$R(10)
 .  s Result=$T
 .  i Result d                           ; Do our stuff if we allocated the dev
 .  .  s @G@(Device,"Job")=$J            ; Set global
 .  .  h 1                               ; Give other jobs a chance
 .  .  i @G@(Device,"Job")'=$J d         ; Check for a stolen device
 .  .  .  s $ze="<STOLEN RID>"
 .  .  .  g errorTrap
 .  s @G@(Device)=+$G(@G@(Device))+1
 .  c Device
 q
  
errorTrap 
 s $zt="^%ETN"
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ZR=$ZR
 s ^Interlock("error")=$ze
 g ^%ETN
 q
  
  

JobTest.INT.1.58638,51696.
JobTest ;
 ;
 ; 07/24/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ; 02/21/01 AFH Fixed errors in Create.  In the created routines Slave
 ;                   and SlaveMan, the generated code had syntax errors.
 ;                   This caused the jobs spawned by JobSyn to die, hence
 ;                   more were started than completed. 
 ;
 w !
 w "JobTest",!
 w "-------",!
 w "JobTest will start a user specified number of jobs, each of which starts jobs",!
 w "themselves.  Each job uses parameters which include passing the local symbol",!
 w "table to the job started.  The size of the symbol table passed is a random",!
 w "percentage of $S for the job starting the process.  The processes started sets",!
 w "one global and quites.",!
 w !
 w "Please use Start^JobTest(jobs) to start this test.",!
 w "jobs = number of jobs to start",!
 w "The default value will start a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^JobTest($zu(86),"PID")) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^JobTest($zu(86),"PID")=jobs
 f i=1:1:jobs j Run
 ;f i=1:1:jobs d Run
 q
 
  
Status() 
 ; Check activity in the CPU for JobTest jobs
 ; slowTime is slightly more than the maximum timeout that JobSyn() uses when
 ; jobbing off a slave test
 ; deadTime is roughly 15 seconds more than slowTime
 q $$Status^Library("1""JobTest""",32,45,"^JobTest("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 n start
 s ^JobTest($zu(86),"stop")=""
 s start=$zh
 f  q:($zh-start)>15  q:$e($$Status,1,17)="OK -- Not running"
 q
 
Result() 
 n status,Started,notStarted,Completed,result,out,file
 q:$d(^JobTest($zu(86),"error")) "FAIL -- "_^JobTest($zu(86),"error")
 q:$d(^JobTest($zu(86)))=0 "FAIL -- Test data are missing."
 s Started=+$g(^JobTest($zu(86),"Started"))
 s NotStarted=+$g(^JobTest($zu(86),"NotStarted"))
 s Completed=+$g(^JobTest($zu(86),"Completed"))
 s Stime=+$g(^JobTest($zu(86),"Start Time"))
 s Etime=+$g(^JobTest($zu(86),"End Time"))
 s Rtime=Etime-Stime,Ttime=Started/Rtime
 s result="Started="_Started_"  Not Started="_NotStarted_"  Completed="_Completed_" Jobs Started per second="_$j(Ttime,0,2)_$c(13,10)
 q:Started>Completed result_"FAIL -- Some jobs failed to complete"
 s status=$$Status
 s file="JobTest.txt"
 i $e(status,1,17)="OK -- Not running" d  q result_"PASS"
 . o file:"WNS":3 q:'$t  u file w $tr(result,$c(13,10))_" Pass",! c file
 i $e(status,1,2)="OK" d  q result_"FAIL -- Still running."
 . o file:"WNS":3 q:'$t  u file w $tr(result,$c(13,10))_" FAIL -- Still running",! c file
 o file:"WNS":3 i $t u file w $tr(result,$c(13,10))_" FAIL -- "_status,! c file
 q result_"FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by JobTest routine
 i $d(^JobTest($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 s Manager=$g(^JobTest($zu(86),"Manager"))
 s:Manager="" Manager="%SYS"
 s JTDIR=$g(^JobTest($zu(86),"JTDIR"))
 s:JTDIR="" JTDIR=$zu(5)
 s zu5=$ZU(5,Manager)
 k ^ROUTINE("SlaveMan")
 k ^rOBJ("SlaveMan")
 s zu5=$ZU(5,JTDIR)
 k ^ROUTINE("Slave")
 k ^rOBJ("Slave")
 k ^JobTest($zu(86))
 q
  
Run 
 s $zt="errorTrap"                    ; Sets error trap
 s ^JobTest($zu(86),"PID",$J)=""         ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 ; New variables
 n zu5                           ; Store result from $ZU(5)
 n Manager,JTDIR                 ; Manager and JobTest directory names
 n Array                         ; Array which takes up space in symbol table
 n TestNum                       ; Test to be run
 n started                       ; Indicates whether or not a test started
 ; Initialize variables
 s zu5=""
 d ^%ST
 s Manager=$g(%ST("MGRNSP"),"^^"_$g(%ST("MGDIR")))
 s JTDIR=$ZU(5)
 s ^JobTest($zu(86),"Manager")=Manager
 s ^JobTest($zu(86),"JTDIR")=JTDIR
 s Array=""
 ; Create slave job routines
 d Create(zu5,Manager,JTDIR)
 ; Perform Test
 s ^JobTest($zu(86),"Start Time")=$zh
 f  q:$d(^JobTest($zu(86),"stop"))  d
 .  ; Pick a percentage to fill up the symbol table and do it
 .  d FillUp(($R(101)/100)*$S,Array)
 .  ; Get parameters for JOB command
 .  s TestNum=$R(6)+1
 .  d JobSyn+TestNum
 .  s started=$t
 .  d:started
 .  .  l ^JobTest($zu(86),"Started")
 .  .  s ^JobTest($zu(86),"Started")=+$G(^JobTest($zu(86),"Started"))+1
 .  .  s ^JobTest($zu(86),"Started",TestNum)=$G(^JobTest($zu(86),"Started",TestNum))+1
 .  .  l
 .  d:'started
 .  .  l ^JobTest($zu(86),"NotStarted")
 .  .  s ^JobTest($zu(86),"NotStarted")=+$G(^JobTest($zu(86),"NotStarted"))+1
 .  .  s ^JobTest($zu(86),"NotStarted",TestNum)=$G(^JobTest($zu(86),"NotStarted",TestNum))+1
 .  .  l
 s ^JobTest($zu(86),"End Time")=$zh
 k ^JobTest($zu(86),"PID",$J)
 l ^JobTest($zu(86),"PID")
 s ^JobTest($zu(86),"PID")=+$g(^JobTest($zu(86),"PID"))-1
 q
  
Create(zu5,Manager,JTDIR) 
 ; New Variables
 n Slave1                        ; Line 1
 n Slave2                        ; Line 2
 n SlaveM1                       ; Line 3
 n SlaveM2                       ; Line 4
 ; Quit if routines already exist
 q:$D(^ROUTINE("Slave",0,0))
 ; Initialize Variables
 s Slave1="Slave"
 s Slave1=Slave1_" s $zt=""errorTrap^JobTest"""
 s Slave1=Slave1_" k "
 s Slave1=Slave1_" s ^JobTest("_$c(34)_$zu(86)_$c(34)_",""Slave"",$J)="""""
 s Slave1=Slave1_" l ^JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")"
 s Slave1=Slave1_" s ^JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")=+$G(^JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed""))+1"
 s Slave1=Slave1_" q"  ; When we quit, our lock should be released
 s Slave2="Slave2(Param)"
 s Slave2=Slave2_" s $zt=""errorTrap^JobTest"""
 s Slave2=Slave2_" k "
 s Slave2=Slave2_" s ^JobTest("_$c(34)_$zu(86)_$c(34)_",""Slave"",$J)="""""
 s Slave2=Slave2_" l ^JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")"
 s Slave2=Slave2_" s ^JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")=+$G(^JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed""))+1"
 s Slave2=Slave2_" q"
 s SlaveM1="Slave"
 s SlaveM1=SlaveM1_" s $et=""s ^["""""_JTDIR_"""""]JobTest("""_$c(34)_$zu(86)_$c(34)_""",""""error"""")=$ze g ^%ETN"""
 s SlaveM1=SlaveM1_" k "
 s SlaveM1=SlaveM1_" s ^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""SlaveMan"",$J)="""""
 s SlaveM1=SlaveM1_" l ^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")"
 s SlaveM1=SlaveM1_" s ^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")=+$G(^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed""))+1"
 s SlaveM1=SlaveM1_" q"
 s SlaveM2="Slave2(param)"
 s SlaveM2=SlaveM2_" s $et=""s ^["""""_JTDIR_"""""]JobTest("""_$c(34)_$zu(86)_$c(34)_""",""""error"""")=$ze g ^%ETN"""
 s SlaveM2=SlaveM2_" k "
 s SlaveM2=SlaveM2_" s ^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""SlaveMan"",$J)="""""
 s SlaveM2=SlaveM2_" l ^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")"
 s SlaveM2=SlaveM2_" s ^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed"")=+$G(^["""_JTDIR_"""]JobTest("_$c(34)_$zu(86)_$c(34)_",""Completed""))+1"
 s SlaveM2=SlaveM2_" q"
 ; Create Routines
 x "zr  zi Slave1,Slave2 zs Slave"
 x "s zu5=$ZU(5,Manager) zr  zi SlaveM1,SlaveM2 zs SlaveMan s zu5=$ZU(5,JTDIR)"
 q
  
FillUp(Percent,Array) 
 ; Percent = how much should the symbol table be filled
 ; Fill up symbol table
 k Array
 f index=1:1 s Array(index,index+$R(100),"This is going to fill up the whole symbol table if I let it")=index q:Percent>$S-1000
 q
  
JobSyn(zu5) 
 j ^Slave::$R(30) q
 s zu5=$ZU(5,Manager) j ^SlaveMan::$R(30) s zu5=$ZU(5,JTDIR) q
 j Slave^Slave::$R(30) q
 s zu5=$ZU(5,Manager) j Slave^SlaveMan::$R(30) s zu5=$ZU(5,JTDIR) q
 j Slave2^Slave(1)::$R(30) q
 s zu5=$ZU(5,Manager) j Slave2^SlaveMan(1)::$R(30) s zu5=$ZU(5,JTDIR) q
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^JobTest($zu(86),"error")=$ze
 g ^%ETN
 q
  

KillTest.INT.1.58610,65256.
KillTest        ;
 ;
 ; 08/07/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "KillTest",!
 w "--------",!
 w "KillTest starts up a user specified number of three different processes:",!
 w !
 w "     Sequential continually sets sequential nodes of a global ^killTest#,",!
 w "     where # is an integer.",!
 w !
 w "     Random continually sets random nodes of a glboal ^killTest#, where #",!
 w "     is an integer.",!
 w !
 w "     Kill continually kills random ^killTest# globals.  The user specifies",!
 w "     how long Kill processes should HANG between KILLs.",!
 w !
 w "Please use Start^KillTest(sequentialJobs,randomJobs,killJobs,hangTime) to start",!
 w "this test.",!
 w "sequentialJobs = number of sequential node jobs to start",!
 w "randomJobs     = number of random node jobs to start",!
 w "killJobs       = number of kill jobs to start",!
 w "hangTime       = number of seonds to wait between kills",!
 w "The default values will start a minimal meaningful test.",!
 q
  
Start(sequentialJobs,randomJobs,killJobs,hangTime) 
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^KillTest($zu(86),"PID")) Destroy
 s sequentialJobs=$g(sequentialJobs,1)
 s randomJobs=$g(randomJobs,1)
 s killJobs=$g(killJobs,1)
 s hangTime=$g(hangTime,5)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With sequentialjobs="_sequentialJobs_" randomjobs="_randomJobs_" killjobs="_killJobs_" hangtime="_hangTime)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^KillTest($zu(86),"sequentialJobs")=sequentialJobs
 s ^KillTest($zu(86),"randomJobs")=randomJobs
 s ^KillTest($zu(86),"killJobs")=killJobs
 s ^KillTest($zu(86),"hangTime")=hangTime
 s ^KillTest($zu(86),"PID")=sequentialJobs+randomJobs+killJobs
 f i=1:1:sequentialJobs j KTCreatS(i)
 f i=1:1:randomJobs j KTCreatR(i)
 f i=1:1:killJobs j KTKill(hangTime)
 q
  
Status() 
 ; Check activity in the CPU for KillTest jobs
 n slowTime,deadTime
 s slowTime=$G(^KillTest($zu(86),"hangTime"),7)
 s deadTime=slowTime+15
 q $$Status^Library("1""KillTest""",slowTime,deadTime,"^KillTest("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops all currently running KillTest jobs using their PIDs
 d Stop^Library("^KillTest("_$c(34)_$zu(86)_$c(34)_",""PID"")",30)
 q
  
Result() 
 n status
 q:$d(^KillTest($zu(86),"error")) "FAIL -- "_^KillTest($zu(86),"error")
 q:$d(^KillTest)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by KillTest routine
 n i,max
 i $d(^KillTest),$e($$Status,1,17)'="OK -- Not running" d Stop
 s max=$g(^KillTest($zu(86),"sequentialJobs"))+$g(^KillTest($zu(86),"randomJobs"))
 s:max=0 max=50
 f i=1:1:max k @("^killTest"_i)
 k ^KillTest
 q
  
KTCreatS(i) 
 ; SETs sequential nodes of global ^KillTestn
 s $zt="errorTrap"                       ; Sets error trap
 s ^KillTest($zu(86),"PID",$J)=""                ; Records job numbers
 n G                                     ; Global reference name
 n Start                                 ; Starting subscript
 n End                                   ; Ending subscript
 n GloRef                                ; Global reference to set
 s G="^killTest"_i
 ;write message to cconsole.log
 i $zu(9,"",$zn_" CreateS Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 f j=1:1 d
 .  s Start=$R(5000)
 .  s End=Start+$R(5000)
 .  f index=Start:1:End d
 .  .  s @(G_"("_j_")")=$R(10000)
 q
  
KTCreatR(i) 
 ; SETs random nodes of global ^KillTestn
 s $zt="errorTrap"                       ; Sets error trap
 n G                                     ; Global reference name
 n Start                                 ; Starting subscript
 n End                                   ; Ending subscript
 s ^KillTest($zu(86),"PID",$J)=""                ; Records job numbers
 s G="^killTest"_i
 ;write message to cconsole.log
 i $zu(9,"",$zn_" CreatR Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 f j=1:1 d
 .  s Start=$R(50000000)
 .  s End=Start+$R(3000)
 .  f index=Start:1:End d
 .  .  s @(G_"("_$R(j)_","_$R(j)_","_$R(j)_","_$R(j)_")")=$R(10000)
 q
  
KTKill(hangTime) 
 ; KILLs random nodes of ^killTestn
 s $zt="errorTrap"                       ; Sets error trap
 n temp,max
 s ^KillTest($zu(86),"PID",$J)=""                ; Records job numbers                
 ;write message to cconsole.log
 i $zu(9,"",$zn_" Kill Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 f  d
 .  s max=^KillTest($zu(86),"sequentialJobs")
 .  s temp=^KillTest($zu(86),"randomJobs")
 .  s:temp>max max=temp
 .  k @("^killTest"_($R(max)+1))
 .  h hangTime
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^KillTest($zu(86),"error")=$ze
 g ^%ETN
 q
  
  

Library.INT.1.58644,56024.
Library ;
 ;
 ; 07/24/97 MDS Revised routine.
 ; 05/30/00 JMB Added IsUnicode() function and review/document 
 ;                   other Unicode functions.
 ; 03/20/01 AFH Changed loop in Status subroutine to not quit as soon as
 ;                   result is not 'OK', but to keep trying for good results
 ;                   until it gets them or exceeds dead time.
 ;
 w !
 w "Library",!
 w "-------",!
 w "The Library contains routines that are commonly used by all the tests.",!
 w "These should never be called directly from the command prompt.  They",!
 w "are intended for use by the test routines themselves.",!
 w !
 w "Status(routineName,slowTime,deadTime,PID) -- Checks the collective status",!
 w "of a set of test jobs.",!
 w "pattern     = a pattern for recognizing valid names of routines that a given",!
 w "              process may be running.  Semantics are the same as the right",!
 w "              side of the ? operator.",!
 w "slowTime    = maximum number of seconds a process can remain motionless",!
 w "              before being considered ""slow""",!
 w "deadTime    = maximum number of seconds a process can remain motionless",!
 w "              before being considered ""dead""",!
 w "PIDarray    = name of an array whose subscripts are PID values and whose root",!
 w "              contains the expected number of jobs running.",!
 w !
 w "Stop(PID,waitTime) -- Kills a set of test jobs.",!
 w "PID      = the same meaning as PID in Status above",!
 w "waitTime = total number of seconds to wait for all jobs to die",!
 w !
 w "Version() -- Returns the version number of this installation of Suites.",!
 w "result is a real number x.y, where x is the major version number and y is the",!
 w "minor version number.  y is zero padded to three places, so a higher version",!
 w "will always be greater than a lower version when the entire values are compared.",!
 w !
 w "Speed() -- Returns a scaling factor for calculating timeout values.",!
 w "result = 1.0 means the system is running at calibrated speed.",!
 w "result < 1.0 means the system is running faster.",!
 w "result > 1.0 means the system is running slower.",!
 q
 
Status(pattern,slowTime,deadTime,PIDarray) 
 s deadTime=deadTime*2  ;fudge factor: tests are timing out too soon
 s $zt="StatusTrap"
 n pid,pidlist,start,result,present,expected,count,info
 l @PIDarray
 s pid=$o(@PIDarray@(""))
 s expected=+$g(@PIDarray,0)
 i pid="" d  g StatusExit
 .  i (expected=0) s result="OK -- Not running"
 .  e  s result="DUD none in "_PIDarray_" expected "_expected ;AFH 6/15/00
 s result="OK"
 f count=0:1 q:pid=""  q:result'="OK"  d
 .  s present=$ZU(67,0,+pid)
 .  i present=0 s result="MIA $ZU(67,0) reports process not in PID table" q  ;AFH 6/15/00
 .  i present=1 s result="DEAD $ZU(67,0) reports process in PID table but not responding" q  ;AFH 6/15/00
 .  s pidlist(pid)=$P($V(-1,pid),"^",7)
 .  s pid=$O(@PIDarray@(pid))
 g:result'="OK" StatusExit
 i count'=expected s result="DUD "_count_" processes running expected "_expected_" processes" g StatusExit ;AFH 6/15/00
 s start=$$zh^Library
 ;f  q:($$zh^Library-start)>deadTime  q:$d(pidlist)<10  q:result'="OK"  d
 f  q:($$zh^Library-start)>deadTime  q:$d(pidlist)<10  s result="OK" d  ; AFH 3/20/01 let it keep trying till it hits deadtime
 .  s pid=""
 .  f  s pid=$o(pidlist(pid)) q:pid=""  q:result'="OK"  d
 .  .  s present=$ZU(67,0,+pid)
 .  .  i present=0 d  q
 .  .  .  i @PIDarray@(pid)=1 k @PIDarray@(pid),pidlist(pid) q
 .  .  .  s result="MIA went missing during activity check" ;AFH 6/15/00
 .  .  i present=1 s result="DEAD went dead during activity check" q  ;AFH 6/15/00
 .  .  s info=$v(-1,pid)
 .  .  i $p(info,"^",6)'?@pattern s result="MIA process not running routine expected" q  ;AFH 6/15/00
 .  .  k:$p(info,"^",7)>pidlist(pid) pidlist(pid)
 .  h 0.1
StatusExit 
 l
 q:result'="OK" result
 s elapsedTime=$$zh^Library-start
 i $d(pidlist),elapsedTime>deadTime q "DEAD timed out before able to verify activity of all processes" ;AFH 6/15/00
 q:elapsedTime>slowTime "OK -- Slow"
 q "OK"
StatusTrap 
 s $zt="^%ETN"
 l
 q:$e($ze,1,7)="<NOJOB>" "MIA <NOJOB> error" ;AFH 6/15/00
 q "ERROR -- "_$ze
  
  
Stop(PIDarray,waitTime) 
 ; Our goal is to kill off all the processes and empty the PIDarray.
 ; However, if a process is MIA, we won't remove it from the PIDarray,
 ; because it represents a failure of a test, and that test needs the
 ; entry in the PIDarray in order to detect the problem.  However, in
 ; order for this routine to terminate, we need to empty a PID list, so
 ; we make an intermediate copy and simply post deletions to the PIDarray.
 ; This routine could be improved by adding a routineName with similar
 ; semantics to Status() above.  However, in most circumstances, there
 ; won't be another type of job that has reused a PID; and even if there
 ; is such a job, it is probably another test that is also destined to be
 ; stopped.
 n pid,start,result,pidlist
 s start=$$zh^Library
 s pid=""
 f  s pid=$o(@PIDarray@(pid)) q:pid=""  s pidlist(pid)=""
 f  q:($$zh^Library-start)>waitTime  q:$d(pidlist)<10  d
 .  s pid=""
 .  f  s pid=$o(pidlist(pid)) q:pid=""  d
 .  .  s result=$ZU(4,pid)
 .  .  s:result=1 @PIDarray@(pid)=1
 .  .  d:result=-3
 .  .  .  k pidlist(pid)
 .  .  .  d:@PIDarray@(pid)=1
 .  .  .  .  k @PIDarray@(pid)
 .  .  .  .  s @PIDarray=$g(@PIDarray)-1
 .  h 0.1
 q
  
Version() 
 q "6.205"
 ;
zh() ;
 n h s h=$ztimestamp
 q $p(h,",",1)*86400+$p(h,",",2)
 ; 
zBitGet(pos) ;General zbitget function
 s $zt="zBitTrap"
 set value=0
 if $zbitget($zversion(0),pos) set value=1
 q value
zBitTrap ;
 i $ze["<FUNCTION"!($ze["<SYNTAX") q 0
 g ^%ETN
 ;
Speed() 
 n start,i,temp,local
 s ^Library("Speed")=""
 s start=$$zh
 f i=0:1  q:($$zh-start)>.5  d
 .  ; These lines should be representative of the kinds of things that
 .  ; the real code will be doing.  They are based loosely on ^Benchmark.
 .  s ^Library("Speed")=i
 .  s local("barf")=i
 .  s temp=$o(^Library(""))
 .  s temp=$l(temp)
 .  s temp=$zu(67,0,$j)
 .  x "s temp=i"
 .  s temp=i+55-2*3/7
 .  i temp=i
 .  k local
 .  i $d(local)
 k ^Library("Speed")
 s:i=0 i=1
 q 1000/i  ; The numerator is our calibration factor.  This value is from an NT 4.0 system with Pentium 133 Mhz.
 
IsUnicode() 
 ; Tests a machine for Unicode capabilities and return answer.
 ; 0 = No, and 1 = Yes 
 n x
 s x=$$zBitGet^Library(1)
 q x  
  
 ;------------------------------------------------------------------------
 ; The following set of functions manage a collection of unicode characters.
 ; A collection is passed as the name of a node (global or local).
 ; The format of the node is determined by this set of functions rather
 ; than by the caller.  Specifically, the collection is stored as three
 ; nodes under the given node, each approximately 21 K in length.
 
 ; Using these functions on a Non-Unicode system is fine also because 
 ; they simply manage a list of characters of which only 255 will be 
 ; available.
 
 ; The UnicodeAdd() function builds a list of valid characters for use
 ; with the suites.      
UnicodeAdd(collection,character) 
 n node,i,length,low,high,current
 s character=$a(character)
 s node=3
 s:character<42000 node=2
 s:character<21000 node=1
 s:$d(@collection@(node))=0 @collection@(node)=""
 s length=$l(@collection@(node))
 s low=1
 s high=length
 f  q:low'<high  d
 .  s i=(high+low)\2
 .  s current=$a($e(@collection@(node),i))
 .  i current>character s high=i-1 q
 .  i current<character s low=i+1 q
 .  ; We've found the character, so break the loop by setting low=high=i.
 .  s low=i
 .  s high=i
 ; Coming out of the loop, both low and high should point to the same character.
 ; However, it's possible that the collection was empty, in which case low=1
 ; and high=0.  Therefore, we use low to locate characters in the collection,
 ; and high to choose what action to take on the collection.
 s current=$a($e(@collection@(node),low))
 q:current=character
 i current<character d  q
 .  s:high<1 @collection@(node)=$c(character)
 .  s:high>0 @collection@(node)=$e(@collection@(node),1,high)_$c(character)_$e(@collection@(node),high+1,length)
 ; If we get to this point, then character in collection is greater than new character.
 s:high>1 @collection@(node)=$e(@collection@(node),1,high-1)_$c(character)_$e(@collection@(node),high,length)
 s:high<2 @collection@(node)=$c(character)_@collection@(node)
 q
  
 ; The UnicodeRemove() function will remove a specified character from 
 ; the list valid characters.  Any character from 0 to 65536 is a valid
 ; character for a subscript name or data value, however there are 
 ; numerous locale dependant characters even in the normal ASCII set
 ; which are not allowed in global or local variable names.  This ideally
 ; should have been tested with $ZNAME(char), but the suites (LockSimple
 ; for example) simply trap the error given when trying to use an 
 ; invalid character in a global name and then call this function to 
 ; remove it from the list all together which is ok except that means 
 ; that it will not be used in subscript or data when it could be.
UnicodeRemove(collection,character) 
 n node
 s node=3
 s:$a(character)<42000 node=2
 s:$a(character)<21000 node=1
 q:$d(@collection@(node))=0
 s @collection@(node)=$tr(@collection@(node),character)
 q
  
 ; The UnicodeLength() funtion returns the length of all the valid
 ; characters in the collection based on the given character set.
 
UnicodeLength(collection) 
 n result
 s result=0
 s:$d(@collection@(1)) result=result+$l(@collection@(1))
 s:$d(@collection@(2)) result=result+$l(@collection@(2))
 s:$d(@collection@(3)) result=result+$l(@collection@(3))
 q result
 
 ; The UnicodeFetch() function retrieves a character from the specified
 ; collection
 
UnicodeFetch(collection,index)  ; index is one-relative (like $extract)
 i $d(@collection@(1)) q:$l(@collection@(1))'<index $e(@collection@(1),index) s index=index-$l(@collection@(1))
 i $d(@collection@(2)) q:$l(@collection@(2))'<index $e(@collection@(2),index) s index=index-$l(@collection@(2))
 i $d(@collection@(3)) q:$l(@collection@(3))'<index $e(@collection@(3),index)
 q ""
  

LockFair.INT.1.58610,65256.
LockFair ;
 r !,"# of client systems (include yourself): <1>",cn s:cn="" cn=1
 r !,"# of jobs on each client system: ",jn q:jn=""
 r !,"Name Space to server of the lock (if remote): ",nsp q:nsp=""
 r !,"File name of result : ",tnn q:tnn=""
 w !,"Start Server <Yes>? " r svr s svr=(svr=""!($e(svr)="y")!($e(svr)="Y"))
 w !,"Test stand alone for each system <Yes>? " r stl s stl=(stl=""!($e(stl)="y")!($e(stl)="Y"))
 w !,"Run all client systems without server <Yes>? " r cls s cls=(cls=""!($e(cls)="y")!($e(cls)="Y"))
 s nsp(1)=$zu(5),nsp(cn+1)=nsp
 f i=1:1:cn d
 . if i=1 w !,"Name space of client ",i," to start jobs must be ",$zu(5) s nsp(i)=$zu(5)
 . e  w !,"Name space of client ",i," to start jobs : " r nsp(i)
 . w !,"number of iteration for each test on client ",i,": " r loopcnt(i)
 i svr d
 . w !,"# of jobs on Server (",jn,") ?" r rjn s:rjn="" rjn=jn
 . w !,"Number of iterations for each test on Server (",loopcnt(1)*5,") ?" r loopcnt(cn+1) s:loopcnt(cn+1)="" loopcnt(cn+1)=loopcnt(1)*5
 r !,"Start test # <0> (0,1,2) : ",stn s:stn="" stn=0
 r !,"End test # <1> (0,1,2) : ",endn s:endn="" endn=1
 r !,"Start from background <Yes>? ",bk
 i bk=""!($e(bk)="y")!($e(bk)="Y") s pdev="lsdrv.txt" job backj:(:1) q
 s pdev=0
 g forj
backj ;
 o pdev:"WNS"
forj ;
 o tnn:"WNS"
 k iter,time
 s tcn=$s(svr:cn+1,1:cn)
 f test=stn:1:endn d
 . u pdev
 . i stl f i=1:1:tcn d StartCS(i,0) d
 . . f  q:$d(^|nsp(i)|LockFair("time"))  h 1
 . . s iter(test,"stl",i)=^|nsp(i)|LockFair("iterpsec"),time(test,"stl",i)=^|nsp(i)|LockFair("time")
 . i cls d
 . . k ^|nsp|LockSync f i=1:1:cn d StartCS(i,cn)
 . . f i=1:1:cn d
 . . . w !,"Waiting for client ",i," to complete."
 . . . f  q:$d(^|nsp(i)|LockFair("time"))  h 2
 . . . s iter(test,"cls",i)=^|nsp(i)|LockFair("iterpsec"),time(test,"cls",i)=^|nsp(i)|LockFair("time")
 . i svr d
 . . k ^|nsp|LockSync f i=1:1:cn+1 d StartCS(i,cn+1)
 . . f i=1:1:cn+1 d
 . . . w !,"Waiting for ",$s(i=(cn+1):"server",1:"client "_i)," to complete."
 . . . f  q:$d(^|nsp(i)|LockFair("time"))  h 2
 . . . s iter(test,"svrcls",i)=^|nsp(i)|LockFair("iterpsec"),time(test,"svrcls",i)=^|nsp(i)|LockFair("time")
 d record
 c tnn
 c:pdev'=0 pdev
 q
back(cn,jn,rjn,nsp,tnn,loopcnt,stl,cls,svr) ; Entry point for starting the test on back ground
 s pdev="lsdrv.txt"
 o pdev:"WNS"
 g backj
record ;
 u tnn
 w cn,",",jn,",",svr i svr w ",",rjn,",",loopcnt(cn+1),",",stn,",",endn
 f i=1:1:cn w !,loopcnt(i)
 f type="iter","time" f tt="stl","cls","svrcls" d
 . s tcn=$s(tt="stl":$s(svr:cn+1,1:cn),tt="svrcls":cn+1,1:cn)
 . f test=stn:1:endn d
 . . i $d(@type@(test,tt)) f i=1:1:tcn d
 . . . w !,$s(type="iter":"Iteration/second,",1:"Time Used,")
 . . . w $s(tt="stl":1,tt="cls":2,1:3)
 . . . w $s(i=(cn+1):"Server",1:"Client "_i),","
 . . . w test+1,$s($zu(68,50):"New,",1:"Old,")
 . . . w @type@(test,tt,i)
 u pdev
 q
report(oldf,newf,outf)
 i $ZU(68,40,1)  ; get eof back in $ZEOF w/out err trap
 o:oldf'="" oldf:"R" o:newf'="" newf:"R" o outf:"WNS"
 k res
 i oldf'="" u oldf r a
 i newf'="" u newf r a
 s cn=$p(a,","),jn=$p(a,",",2),svr=$p(a,",",3) i svr s rjn=$p(a,",",4),loopcnt(cn+1)=$p(a,",",5)
 s stn=$p(a,",",6),endn=$p(a,",",7)
 f i=1:1:cn d
 . i oldf'="" u oldf r loopcnt(i)
 . i newf'="" u newf r loopcnt(i)
 u outf w !,"The unit is iteration/sec"
 f i=1:1:cn d
 . w !,"Client ",i," : # of jobs=",jn," iteration=",loopcnt(i)
 i svr w !,"Server: # of jobs=",rjn," iteration=",loopcnt(cn+1)
 w !
 f i=stn:1:endn w !,"Test ",i+1,": ",$T(@i+1)
 i oldf'="" u oldf f  r a q:$ZEOF  s res($p(a,",",1),$p(a,",",2),$p(a,",",3))=$p(a,",",4,999)
 i newf'="" u newf f  r a q:$ZEOF  s res($p(a,",",1),$p(a,",",2),$p(a,",",3))=$p(a,",",4,999)
 u outf
 s t1="" f  s t1=$o(res(t1)) q:t1=""  d
 . w !!,t1,!,"Running Systems"
 . f i=stn:1:endn w:newf'="" ",New Lock Test ",i+1 w:oldf'="" ",Old Lock Test ",i+1
 . s t2="" f  s t2=$o(res(t1,t2)) q:t2=""  d
 . . w !,$e(t2,2,99)," ",$s($e(t2)=1:"Only",$e(t2)=2:"(Clients running)",1:"(Clients & Server running)")
 . . s t3="" f  s t3=$o(res(t1,t2,t3)) q:t3=""  d
 . . . w ",",res(t1,t2,t3)
 c outf c:oldf'="" oldf c:newf'="" newf
 q
job(test,jn,nsp,loopcnt,sync) 
 k ^LockFair,^LockFairTrace
 i test=1 s loopcnt=loopcnt\10
 i $ZU(51,3)
 f  q:$ZU(51,3)  h 1  ;wait for wd to finish
 d Start(test,jn,nsp,loopcnt,sync)
 i $ZU(51,3)
 f  q:$ZU(51,3)  h 1  ;wait for wd to finish
done ;
 q
Start(test,jobs,nsp,nlocks,sync) 
 ; Starts up LockFair jobs
 n i,pd,pid,pcnt
 s $zt="errorTrap"
 s jobs=$g(jobs,10)
 ;      Remove old data
 d:$d(^LockFair) Destroy
 s ^LockFair("mstart")=$$Mstart
 ;      Start up the jobs
 s ^LockFair("PID")=jobs
 s pd="^LockFair(""PID"")"
 lock ^LockFairStart(0) ; keep jobs from starting
 f i=1:1:jobs j Run(test,nsp,nlocks,i)
 ; make sure every job is up and ready in 10 seconds
 f i=1:1:100 d  q:pcnt=jobs  h 1
 . s pid="",pcnt=0 f  s pid=$o(@pd@(pid)) q:pid=""  s pcnt=pcnt+1
 ;      let the jobs run NOW
 i sync s xx=$zincr(^|nsp|LockSync) f  q:sync=^|nsp|LockSync  h 1
 lock
 s sttime=$zts
 if pcnt'=jobs w !,"Taking more than 100 seconds to start all(",jobs,") jobs" q 1
 f  q:^LockFair("PID")=0  h 1
 s endtime=$zts
 s r="" s r=$o(^LockFairTrace(r)) q:r=""
 i r s rx=$$Summary(r) s ^LockFair("iterpsec")=loopcnt*jn*jn/rx*1000\1/1000
 s ^LockFair("time")=$$ztdiff(endtime,sttime)
 q 0
Mstart() 
 quit $V($zu(40,2,71)-8,-2,4)
Summary(run) 
 n res,j
 s res=0
 i $d(^LockFairTrace)\10=0 q 0_" No such run"
 s j="" f  s j=$o(^LockFairTrace(run,j)) q:j=""  d
 . s res=res+$li(^LockFairTrace(run,j),2)
 q res
StartCS(i,sync) ;
 w !,"Running ",$s(i=(cn+1):"server",1:"client "_i)," test. jobn=",jn," test=",test," loopcnt=",loopcnt(i)
 k ^|nsp(i)|LockFair
 s ^|nsp(i)|LockFair("parameter")=test_"^"_$s(i=(cn+1):rjn,1:jn)_"^"_loopcnt(i)_"^"_0_"^"_nsp
 i i=(cn+1) j Server^LockFair|nsp(i)|
 e  j Client^LockFair|nsp(i)|
 q
Server ;
 s para=^LockFair("parameter")
 s test=$p(para,"^"),jn=$p(para,"^",2),loopcnt=$p(para,"^",3),sync=$p(para,"^",4)
 s nsp=$zu(5),server=1
 d job(test,jn,nsp,loopcnt,sync)
 q
Client ;
 s para=^LockFair("parameter")
 s test=$p(para,"^"),jn=$p(para,"^",2),loopcnt=$p(para,"^",3),sync=$p(para,"^",4)
 s nsp=$p(para,"^",5),server=0
 d job(test,jn,nsp,loopcnt,sync)
 q
Destroy 
 ; Kills all globals formed by ^LockFair routine
 k ^LockFair,^lockFair 
 ZSYNC  ; wait for kill to complete to remote systems
 q
         
Run(test,nsp,nlocks,jobnum) 
 s $zt="errorTrap"
 n iter,bigt1,bigt2
 s ^LockFair("PID",$J)=jobnum                  ; Records job number
 ;       wait for permission to start
 lock ^LockFairStart(0)
 lock
 s bigt1=$zts
 d @(test)
 ;      record results
 s bigt2=$zts
 s ^LockFairTrace(1,jobnum)=$LB(bigt1,$$ztdiff(bigt2,bigt1),nlocks)
 ;      time to exit
 s x=$I(^LockFair("PID"),-1)
 k ^LockFair("PID",$J)
 quit
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 s ^LockFair("error")=$ze
 g ^%ETN
 q
 
ztdiff(t2,t1) ; t2 - t1
 q ($piece(t2,",")*86400+$p(t2,",",2))-($piece(t1,",")*86400+$p(t1,",",2))
Random(n) 
 quit $r(n) ; can be modified later to record the random number sequence etc.
 ;
0 
 f iter=1:1:nlocks lock +^|nsp|lockFair("SAMENODE") lock -^|nsp|lockFair("SAMENODE")
 q
1 
 f iter=1:1:nlocks lock +^|nsp|lockFair("SAMENODE") s ^|nsp|lockFair("set")=$j lock -^|nsp|lockFair("SAMENODE")
 q
2
 f iter=1:1:nlocks s ^|nsp|EJRLOG($J)="" L +^|nsp|EJRLOG(0) s EJR=$g(^|nsp|EJRLOG(0)) s ^|nsp|EJRLOG(0)=EJR+1 L -^|nsp|EJRLOG(0) L +^|nsp|EJRLOG L -^|nsp|EJRLOG
 q 
3
 f iter=1:1:nlocks s ^|nsp|EJRLOG($J)="" L +^|nsp|EJRLOG(0,1) s EJR=$g(^|nsp|EJRLOG(0)) s ^|nsp|EJRLOG(0)=EJR+1 L -^|nsp|EJRLOG(0,1) L +^|nsp|EJRLOG(0) L -^|nsp|EJRLOG(0)
 q 
 
 

LockIncremental.INT.1.58643,42263.
LockIncremental ;
 ;
 ; Tests incremental LOCKing and runs until a user stops it
 ;
 ; 07/24/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;                   
 ; 04/25/01 RDT Increased the amount of time to wait before the status of 
 ;               LockIncremental jobs is reported as not active (MIA, Dead, etc.)
 ;
 w !
 w "LockIncremental",!
 w "---------------",!
 w "LockIncremental performs incremental locks on globals.  The LockIncremental",!
 w "Suite contians the following four tests:",!
 w !
 w "         1)  Incremental locks in sequential order (one per M command)",!
 w "         2)  Incremental locks in non-sequential order (one per M command)",!
 w "         3)  Incremental locks in sequential order (all in one M command)",!
 w "         4)  Incremental locks in non-sequential order (all in one M command)",!
 w !
 w "Each LockIncremental job uses the same four globals: ^lockIncremental1,",!
 w "^lockIncremental2, ^lockIncremental3, and ^lockIncremental4.",!
 w "Part of the test is checking if another job has stolen a lock.  Therefore,",!
 w "this test is only meaningful when at least two jobs are running.",!
 w !
 w "Please use Start^LockIncremental(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default values will start a minimal meaningful test (2 jobs).",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Set error trap
 d:$d(^LockIncremental($zu(86),"PID")) Destroy
 s jobs=$g(jobs,2)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^LockIncremental($zu(86),"PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for LockIncremental jobs
 n slowTime,deadTime
 s slowTime=2*$g(^LockIncremental($zu(86),"PID"),1)
 ; New wait time for deadTime is 15* the number of jobs running, instead of 15 more plus the slowTime
 ;s deadTime=slowTime+15
 s deadTime=15*$g(^LockIncremental($zu(86),"PID"),1)
 q $$Status^Library("1""LockIncremental""",slowTime,deadTime,"^LockIncremental("_$c(34)_$zu(86)_$c(34)_",""PID"")")
Stop 
 ; Stops currently running LockIncremental jobs using their PIDs
 n pid s pid="" f  s pid=$o(^LockIncremental($zu(86),"PID",pid)) q:pid=""  s ^LockIncrementalT($zu(86),"PID",pid,"end")=$h
 d Stop^Library("^LockIncremental("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
Timer ;gives rough time per lock
 d Timer^Library("^LockIncrementalT("_$c(34)_$zu(86)_$c(34)_",""PID"")")
 q        
Result() 
 n status
 q:$d(^LockIncremental($zu(86),"error")) "FAIL -- "_^LockIncremental($zu(86),"error")
 q:$d(^LockIncremental($zu(86)))=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by LockIncremental routine
 i $d(^LockIncremental($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 f i=1:1:4 k @("^lockIncremental"_i)
 k ^LockIncremental($zu(86))
 k ^LockIncrementalT($zu(86))
 q
  
Run 
 s $zt="errorTrap"                    ; Set error trap
 s ^LockIncremental($zu(86),"PID",$J)=""         ; Records job numbers
 s ^LockIncrementalT($zu(86),"PID",$J,"start")=$h
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 n G1                            ; First global (^lockIncremental1)
 n G2                            ; Second global (^lockIncremental2)
 n G3                            ; Third global (^lockIncremental3)
 n G4                            ; Fourth global (^lockIncremental4)
 n PID                           ; This jobs PID number ($J)
 n Test                          ; Test to run (random number)
 s G1="^lockIncremental1"
 s G2="^lockIncremental2"
 s G3="^lockIncremental3"
 s G4="^lockIncremental4"
 s PID=$J                        ; Get PID number
 f  d
 .  s Test=$R(4)
 .  d @(Test)
 q
  
0 
 n L
 s L=0
 l +@G1:10 s:$T L=L+1
 l +@G2:10 s:$T L=L+1
 l +@G3:10 s:$T L=L+1
 l +@G4:10 s:$T L=L+1
 i L=4 d Check l  q
 s ^LockIncrementalT($zu(86),"PID",$J,"failed")=$g(^LockIncrementalT($zu(86),"PID",$J,"failed"))+(4-L)
 l  q
  
1 
 n L
 s L=0
 l +@G2:10 s:$T L=L+1
 l +@G1:10 s:$T L=L+1
 l +@G4:10 s:$T L=L+1
 l +@G3:10 s:$T L=L+1
 i L=4 d Check l  q
 s ^LockIncrementalT($zu(86),"PID",$J,"failed")=$g(^LockIncrementalT($zu(86),"PID",$J,"failed"))+(4-L)
 l  q
  
2 
 n L
 s L=0
 l +(@G1,@G2,@G3,@G4):10 s:$T L=1
 i L d Check l  q
 s ^LockIncrementalT($zu(86),"PID",$J,"failed")=$g(^LockIncrementalT($zu(86),"PID",$J,"failed"))+1
 l  q
  
3 
 n L
 s L=0
 l +(@G2,@G1,@G4,@G3):10 s:$T L=1
 i L d Check l  q
 s ^LockIncrementalT($zu(86),"PID",$J,"failed")=$g(^LockIncrementalT($zu(86),"PID",$J,"failed"))+1
 l  q
 
  
Check 
 ; Checks to make sure LockIncremental globals are valid
 f Index=1:1:4 s @("^lockIncremental"_Index)=PID
 h 2
 f Index=1:1:4 i @("^lockIncremental"_Index)'=PID d
 .  s $ZE="<STOLEN LOCK> In LockIncremental Test"_Test g errorTrap
 l
 s ^LockIncrementalT($zu(86),"PID",$J)=$g(^LockIncrementalT($zu(86),"PID",$J))+4
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^LockIncremental($zu(86),"error")=$ze
 g ^%ETN
 q
  
  

LockMany.INT.1.58610,65256.
LockMany        ;
 ;
 ; Stresses multiple LOCKs.  Jobs do random LOCKs.  All LOCK commands
 ; use different globals except for the last global which is always ^M
 ;
 ; 07/24/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ; 03/20/01 AFH Fixed typo in Status subroutine (hangover bug from
 ;                   cluster changes) which never would have passed a
 ;                   status check.
 ;
 w "LockMany",!
 w "--------",!
 w "LockMany stresses the M LOCK code.  It starts a user",!
 w "specified number of jobs in the background, each of which LOCK many",!
 w "globals.  The test tries to force jobs to unlock some already LOCKed",!
 w "globals because one of the globals near the end of the LOCK list is already",!
 w "LOCKed by another process.  A simple algorithm of the code:",!
 w !
 w "         1)  Lock (^A,^B,^C,^D,^E)",!
 w "         2)  Set ^A,^B,^C and ^E",!
 w "         3)  Check globals to make sure its set to the right value",!
 w "         4)  Unlock global",!
 w !
 w "At the same time, another process is trying to LOCK the following:",!
 w !
 w "         Lock (^a,^b,^c,^d,^E)",!
 w !
 w "One of the two process will have to back out of the LOCK command.",!
 w "Since this test involves interaction between jobs, it is only meaningful",!
 w "if you start at least two jobs.",!
 w !
 w "Please use Start^LockMany(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value starts a minimal meaningful test (2 jobs).",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                     ; Sets error trap
 d:$d(^LockMany($zu(86),"PID")) Destroy
 s jobs=$g(jobs,2)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^LockMany($zu(86),"PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for LockMany jobs
 ; slowTime is a little bit more than the value of HangTime
 ; deadTime is roughly 15 seconds more than slowTime
 q $$Status^Library("1""LockMany""",5,20,"^LockMany("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops currently running LockMany jobs using their PIDs
 n pid s pid="" f  s pid=$o(^LockMany($zu(86),"PID",pid)) q:pid=""  s ^LockManyT($zu(86),"PID",pid,"end")=$h
 d Stop^Library("^LockMany("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
Timer ;gives rough time per lock
 d Timer^Library("^LockManyT("_$c(34)_$zu(86)_$c(34)_",""PID"")")
 q
  
Result() 
 n status
 q:$d(^LockMany($zu(86),"error")) "FAIL -- "_^LockMany($zu(86),"error")
 q:$d(^LockMany($zu(86)))=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS"
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by LockMany routine
 i $d(^LockMany($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^%lockMany
 k ^LockMany($zu(86))
 k ^LockManyT($zu(86))
 q
         
Run 
 s $zt="errorTrap"                     ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^LockMany($zu(86),"PID",$J)=""        ; Records job numbers
 s ^LockManyT($zu(86),"PID",$J,"start")=$h
 f  d
 .  f index=65:1:76 s @($c(index))="^"_$c(index)
 .  f index=97:1:122 s @($c(index))="^"_$c(index)
 .  s Locked=0
 .  s Test=$r(5)
 .  d @Test
 .  d:Locked
 .  .  s ^%lockMany=$J
 .  .  h 3
 .  .  d:^%lockMany'=$J
 .  .  .  l
 .  .  .  s $ze="<LOCK STOLEN> In LockMany Test 'Lock"_Test_"'"
 .  .  .  g errorTrap
 .  .  s ^LockManyT($zu(86),"PID",$J)=$g(^LockManyT($zu(86),"PID",$J))+Locked
 .  l
 q
  
0 l (@A,@B,@C,@D,@E,@F,@G,@H,@I,@J,@K,@L,@m):10
 s:$T Locked=13
 s:'$T ^LockManyT($zu(86),"PID",$J,"failed")=$g(^LockManyT($zu(86),"PID",$J,"failed"))+1
 q
  
1 l (@a,@b,@c,@d,@e,@f,@g,@h,@i,@j,@k,@l,@m):10
 s:$T Locked=13
 s:'$T ^LockManyT($zu(86),"PID",$J,"failed")=$g(^LockManyT($zu(86),"PID",$J,"failed"))+1
 q
  
2 l (@z,@y,@x,@w,@v,@u,@t,@s,@r,@q,@p,@o,@n,@m):10
 s:$T Locked=14
 s:'$T ^LockManyT($zu(86),"PID",$J,"failed")=$g(^LockManyT($zu(86),"PID",$J,"failed"))+1
 q
  
3 l (z,y,x,w,v,u,t,s,r,q,p,o,n,@("^m")):10
 s:$T Locked=14
 s:'$T ^LockManyT($zu(86),"PID",$J,"failed")=$g(^LockManyT($zu(86),"PID",$J,"failed"))+1
 q
  
4 l (@B,@A,@D,@C,@F,@E,@H,@G,@J,@I,@L,@K,@m):10
 s:$T Locked=13
 s:'$T ^LockManyT($zu(86),"PID",$J,"failed")=$g(^LockManyT($zu(86),"PID",$J,"failed"))+1
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^LockMany($zu(86),"error")=$ze
 g ^%ETN
 q
  
  

LockSimple.INT.1.58610,65256.
LockSimple      ;
 ;
 ; Tests the LOCK command and stresses the Lock table
 ;
 ; 07/24/97 MDS Revised routine.        
 ; 05/31/00 JMB Modify lock test to use a single global called "lockSimple" and put a 
 ;                   hang in the chooseTarget routine to allow for multiple jobs to
 ;                   actually contend for the same lock.  These changes allow this 
 ;                   suite to once again be a valid test.  This suite had never been
 ;                   working properly after being modified to support Unicode.
 ; 02/12/01 AFH LockSimple should have been exposing the unicode code bug corrected by
 ;                   SML087 but it wasn't because in characterTrap anything that caused
 ;                   a WIDECHAR error was excluded from the acceptable character list
 ;                   and the suite continued.  Consequently, the only way you may have
 ;                   noticed that this suite was actually failing on Cache 4.1 build 1-50
 ;                   was that w $$Result^LockSimple would report all the wide characters
 ;                   as having been disallowed.  I changed the trapping in characterTrap
 ;                   to $ze["<WIDE CHAR>" and '$$IsUnicode^Library.  This will now report
 ;                   any Wide Character errors on unicode as errors and still exclude wide
 ;                   characters on non-unicode.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "LockSimple",!
 w "----------",!
 w "LockSimple is a simple lock test which contains the following tests:",!
 w ! 
 w "         1)  Simple global lock (no timeout or indirection)",!
 w "         2)  Global lock with a timeout",!
 w "         3)  Global lock using indirection",!
 w "         4)  Global lock with a timeout using indirection",!
 w ! 
 w "All tests use the same global (^lockSimple1).  Each LockSimple job randomly",!
 w "chooses which test to do.  This test involvs contention for a lock, so it",!
 w "is only meaningful if you start at least 2 jobs.",!
 w !
 w "Please use Start^LockSimple(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value starts a minimal meaningful test (2 jobs).",!
 q
  
Start(jobs) 
 n accept,i
 s $zt="errorTrap"
 d:$d(^LockSimple($zu(86),"PID")) Destroy
 s jobs=$g(jobs,2)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^LockSimple($zu(86),"PID")=jobs+2
 j fillAccept
 f  q:$$UnicodeLength^Library("^LockSimple("_$c(34)_$zu(86)_$c(34)_",""accept"")")>96
 j chooseTarget
 f  q:$d(^LockSimple($zu(86),"character"))
 f i=1:1:jobs j Run
 q
  
Status() 
 q $$Status^Library("1(1""LockSimple"",1""Library"")",2,15,"^LockSimple("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 n pid s pid="" f  s pid=$o(^LockSimple($zu(86),"PID",pid)) q:pid=""  s ^LockSimpleT($zu(86),"PID",pid,"end")=$h 
 d Stop^Library("^LockSimple("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
Timer ;gives rough time per lock
 d Timer^Library("^LockSimpleT("_$c(34)_$zu(86)_$c(34)_",""PID"")")
 q
  
Result() 
 n status,result,length,last,comma,current
 q:$d(^LockSimple($zu(86),("error"))) "FAIL -- "_^LockSimple($zu(86),("error"))
 q:$d(^LockSimple($zu(86)))=0 "FAIL -- Test data are missing."
 s result=""
 s accept="^LockSimple("_$c(34)_$zu(86)_$c(34)_",""accept"")"
 d:$d(@accept)
 .  s result="The following characters were disallowed in global names:"_$c(13,10)
 .  s length=$$UnicodeLength^Library(accept)
 .  s last=-1
 .  s comma=""
 .  f i=1:1:length q:$l(result)>30000  d
 .  .  s current=$a($$UnicodeFetch^Library(accept,i))
 .  .  d:current-last>1
 .  .  .  s result=result_comma_(last+1)
 .  .  .  s:current-last>2 result=result_"-"_(current-1)
 .  .  .  s comma=", "
 .  .  s last=current
 .  i $l(result)'>30000,last<65535 d
 .  .  s:last=65534 result=result_comma_"65535"
 .  .  s:last<65534 result=result_comma_(last+1)_"-65535"
 .  s result=result_$c(13,10)
 .  s:$l(result)>30002 result=result_"Did not show all ranges.  Query ^LockSimple($zu(86),""accept"") for a complete list."_$c(13,10)
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" result_"PASS"
 q:$e(status,1,2)="OK" result_"FAIL -- Still running."
 q result_"FAIL -- "_status
  
Destroy 
 n name
 i $d(^LockSimple($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 s name="^lockSimple"
 f  q:name'["^lockSimple"  d
 .  k @name
 .  s name=$o(^$global(name))
 k ^LockSimple($zu(86))
 k ^LockSimpleT($zu(86))
 q
         
Run 
 s $zt="errorTrap"
 s $etrap="g characterTrap"
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^LockSimple($zu(86),"PID",$J)=""              ; Records job number
 s ^LockSimpleT($zu(86),"PID",$J,"start")=$h
 s accept="^LockSimple("_$c(34)_$zu(86)_$c(34)_",""accept"")"
 f  d
 .  s character=^LockSimple($zu(86),"character")
 .  d @($R(4))                           ; Randomly selects type of locking job
 .  s ^LockSimpleT($zu(86),"PID",$J)=$g(^LockSimpleT($zu(86),"PID",$J))+1
 q
  
0  
 l ^lockSimple(character)
 s ^lockSimple(character)=$J
 h 1
 i ^lockSimple(character)'=$J s $ze="Lock stolen in test 0: Simple" g errorTrap
 l
 q
  
1  
 l ^lockSimple(character):10
 i '$t s ^LockSimpleT($zu(86),"PID",$J,"failed")=$g(^LockSimpleT($zu(86),"PID",$J,"failed"))+1 q
 s ^lockSimple(character)=$J
 h 1
 i ^lockSimple(character)'=$J s $ze="Lock stolen in test 1: Timeout" g errorTrap
 l
 q
  
2  
 s node="^lockSimple("""_character_""")"
 l @node
 s @node=$J
 h 1
 s value=@node
 k @node
 i value'=$J s $ze="Lock stolen in test 2: Indirect" g errorTrap
 l
 q
  
3  
 s node="^lockSimple("""_character_""")"
 l @node:10
 i '$t s ^LockSimpleT($zu(86),"PID",$J,"failed")=$g(^LockSimpleT($zu(86),"PID",$J,"failed"))+1 q
 s @node=$J
 h 1
 s value=@node
 k @node
 i value'=$J s $ze="Lock stolen in test 3: Indirect with Timeout" g errorTrap
 l
 q
  
characterTrap 
 s $ecode=""         ; Clear ANSI-style error condition
 i ($ze["<SYNTAX>")!(($ze["<WIDE CHAR>")&('$$IsUnicode^Library)) d  q
 .  l @accept
 .  d UnicodeRemove^Library(accept,character)
 .  l
 g errorTrap
 q
  
chooseTarget 
 s $zt="errorTrap"
 s ^LockSimple($zu(86),"PID",$j)=""
 s accept="^LockSimple("_$c(34)_$zu(86)_$c(34)_",""accept"")"
 f  d
 .  l @accept,^LockSimple($zu(86),"character")
 .  s ^LockSimple($zu(86),"character")=$$UnicodeFetch^Library(accept,$r($$UnicodeLength^Library(accept))+1)
 .  h 5 ;hang to let other jobs have a chance to get the same character
 .  l
 .  s time=$$zh^Library
 .  s length=$$UnicodeLength^Library(accept)
 .  f  q:$$zh^Library-time>3  q:$$UnicodeLength^Library(accept)-length
 q
  
fillAccept 
 s $zt="errorTrap"
 s ^LockSimple($zu(86),"PID",$j)=""
 s accept="^LockSimple("_$c(34)_$zu(86)_$c(34)_",""accept"")"
 f i=0:1:65535 d
 .  l @accept
 .  d UnicodeAdd^Library(accept,$c(i))
 .  l
 l ^LockSimple($zu(86),"PID")
 k ^LockSimple($zu(86),"PID",$j)
 s ^LockSimple($zu(86),"PID")=$g(^LockSimple($zu(86),"PID"))-1
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^LockSimple($zu(86),"error")=$ze
 g ^%ETN
 q
  
  

Math.INT.1.58610,65256.
Math  
 ; revised by MDS, 7/31/97
 ; Test math. GJL ; 08 Nov 91  1:46 PM
 w !
 w "Math",!
 w "----",!
 w "Tests math functions by comparing the values of expressions",!
 w "that are evaluated according to different algorithms.",!
 w !
 w "Please use Start^Math(jobs,precision) to start this test.",!
 w "jobs      = the number of jobs to start",!
 w "precision = the number of significant digits to check (default = 17)",!
 w "The default values will start a minimal meaningful test.",!
 q
  
Start(jobs,precision) 
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^Math) Destroy
 s jobs=$g(jobs,1)
 s precision=$g(precision,17)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs_" precision="_precision)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^Math("precision")=precision
 s ^Math("log","Multiply","error")=0
 s ^Math("log","Divide","error")=0
 s ^Math("log","Square Root","error")=0
 s ^Math("log","ArcSin(Sin)","error")=0
 s ^Math("log","ArcCos(Cos)","error")=0
 s ^Math("log","ArcTan(Tan)","error")=0
 s ^Math("log","IntDiv+Mod","error")=0
 s ^Math("PID")=jobs
 f i=1:1:jobs j Run(precision)
 q
  
Status() 
 ; Check activity in the CPU for Math jobs
 q $$Status^Library("1""Math""",2,15,"^Math(""PID"")")
  
Stop  
 ; Stops all currently running Math jobs using their PIDs
 d Stop^Library("^Math(""PID"")",30)
 q
  
Result() 
 n result,i,error,CRLF,precision,width,line,fail,status,operation
 q:$d(^Math("error")) "FAIL -- "_^Math("error")
 q:$d(^Math)=0 "FAIL -- Test data are missing."
 ; Report on degree of error, if any
 s CRLF=$c(13,10)
 s fail=0
 s precision=$g(^Math("precision"))+1
 s width=precision+2
 s:width<13 width=13
 ; Creat heading
 s result="Operation    "_$j("Largest Error",width)_CRLF
 s line=""
 s $p(line,"-",$l(result)-2)="-"
 s result=result_line_CRLF
 ; Scan thru log
 s operation=$o(^Math("log",""))
 f  q:operation=""  d
 .  s result=result_operation_$j(" ",13-$l(operation))
 .  s error=^Math("log",operation,"error")
 .  s result=result_$j(error,width,precision)_CRLF
 .  s:error fail=1
 .  s operation=$o(^Math("log",operation))
 ; Finish up
 q:fail result_"FAIL"
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" result_"PASS"
 q:$e(status,1,2)="OK" result_"FAIL -- Still running."
 q result_"FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by ^Math routine
 i $d(^Math),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^Math
 q
  
Run(SIGFIG) 
 s $zt="errorTrap"                       ; Sets error trap
 s ^Math("PID",$J)=""                ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s MINERR=1
 f i=1:1:SIGFIG s MINERR=MINERR/10
 s TOTAL=0,ERROR=0
 k ER
 s ER(0)=0
 s TWO=4611686018427387904               ; 2**61, (2**62,... lose significance)
 f  q:$d(^Math("stop"))  d
 .  s VAL1=1
 .  f x=1:1:($r(SIGFIG)+1) s VAL1=VAL1*10
 .  s VAL1=$r(VAL1)+1
 .  i TWO s VAL1=TWO,TWO=TWO/2 i TWO<MINERR s TWO=0
 .  s VAL2=1
 .  f x=1:1:($r(SIGFIG)+1) s VAL2=VAL2*10
 .  s VAL2=$r(VAL2)+1
 .  d testmul q:$d(^Math("stop"))
 .  d testdiv q:$d(^Math("stop"))
 .  d testsqrt q:$d(^Math("stop"))
 .  d testsin q:$d(^Math("stop"))
 .  d testcos q:$d(^Math("stop"))
 .  d testtan q:$d(^Math("stop"))
 .  d testintd q:$d(^Math("stop"))
 q
  
testmul 
 s FUNC="Multiply"
 s X=VAL1,Y=VAL2,PARA=2
 f A=1:1:10 d multiply s X=X/1000 q:(X<MINERR)
 q
  
testdiv 
 s FUNC="Divide"
 s X=VAL1,Y=VAL2,PARA=2
 f A=1:1:15 d divide s X=X/100 q:(X<MINERR)
 q
  
testsqrt 
 s FUNC="Square Root"
 s X=VAL1,PARA=1
 f A=1:1:30 d sqrt s X=X/10 q:(X<MINERR)
 q
  
testsin 
 ; The accuracy of Sin(x) falls off rapidly as X-->pi/2,
 ; hence the division by ten before asinsin.
 s FUNC="ArcSin(Sin)"
 s X=VAL1,PARA=1 d reduce
 f A=1:1:15 s X=X/10 d asinsin q:(X<MINERR)
 q
  
testcos 
 ; The accuracy of Cos(x) falls off rapidly as X-->0,
 ; hence the absence of a for-loop with division by ten.
 s FUNC="ArcCos(Cos)"
 s X=VAL1,PARA=1 i X>.1 d reduce,acoscos
 q
  
testtan 
 s FUNC="ArcTan(Tan)"
 s X=VAL1,PARA=1 d reduce
 f A=1:1:15 d atantan s X=X/10 q:(X<MINERR)
 q
  
testintd 
 s FUNC="IntDiv+Mod" 
 s X=VAL1,Y=VAL2,PARA=2
 f A=1:1:30 d intdmod s X=X/10 q:(X<MINERR)
 q
  
  
 ;-----------------------------------------------------------------------------
 ; Math support functions called to perform the different tests.
  
reduce  
 ; reduce X to the range 0-90 degrees (in radians)
 i X>1.57079632679489661923 s X=X/10 g reduce
 q
  
multiply 
 s TOTAL=TOTAL+1
 s Z=$$mul(X,Y),Z=Z-(X*Y) i Z<0 s Z=-Z
 i Z>(X*Y*MINERR) d error
 q
  
divide  
 s TOTAL=TOTAL+1
 s Z=$$div(X,Y),Z=Z-(X/Y) i Z<0 s Z=-Z
 i Z>(X*Y*MINERR) d error
 q
  
sqrt  
 s TOTAL=TOTAL+1
 s Z=$$Sqrt(X),Z=Z*Z-X i Z<0 s Z=-Z
 i Z>(X*MINERR) d error
 q
  
asinsin 
 s TOTAL=TOTAL+1
 s Z=$$ArcSin($$Sin(X)),Z=Z-X i Z<0 s Z=-Z
 i Z>MINERR d error
 q
  
acoscos 
 s TOTAL=TOTAL+1
 s Z=$$ArcCos($$Cos(X)),Z=Z-X i Z<0 s Z=-Z
 i Z>MINERR d error
 q
  
atantan 
 s TOTAL=TOTAL+1
 s Z=$$ArcTan($$Tan(X)),Z=Z-X i Z<0 s Z=-Z
 i Z>MINERR d error
 q
  
intdmod 
 s TOTAL=TOTAL+1
 ; s Z=(X\Y)*Y+(X#Y),Z=Z-X i Z<0 s Z=-Z
 s Z=X\Y
 s Z=Z*Y
 s Z=Z+(X#Y)
 s Z=Z-X i Z<0 s Z=-Z
 i Z>MINERR d error
 q
  
error  
 l ^Math("log",FUNC)
 d:^Math("log",FUNC,"error")<Z
 .  s ^Math("log",FUNC,"X")=X
 .  s:PARA=2 ^Math("log",FUNC,"Y")=Y
 .  s ^Math("log",FUNC,"error")=Z
 l
 q
  
  
 ;----------------------------------------------------------------------------
 ; "Library" of basic functions
  
mul(a,b) 
 ; a*b (via multiple shifts and adds)
 n i,j,m,n,r,s,sa,sb,sign,t
 i (a=0)!(b=0) q 0
 s sign=1
 i a<0 s sign=sign*(-1),a=-a
 i b<0 s sign=sign*(-1),b=-b
 s r=0,sa=""
 f i=$l(b):-1:1 d
 .  s n=$e(b,i)
 .  i n'="." d mul1 s r=r+(t_sa),sa=sa_"0"
 s i=$l($p(a,".",2))+$l($p(b,".",2))
mfmt  
 i i>$l(r) s r="0"_r g mfmt
 i i s r=$e(r,0,$l(r)-i)_"."_$e(r,$l(r)-i+1,255)
 q (sign*r)
mul1  
 s t=0,sb=""
 f j=$l(a):-1:1 s m=$e(a,j) i m'="." d mul2 s t=t+(s_sb),sb=sb_"0"
 q
mul2  
 s s=0 f k=1:1:n s s=s+m
 q
  
div(a,b) 
 ; a/b (via multiple shifts and subtracts)
 n c,done,n,r,sign,signif,x
 i b=0 s b=b+1
 i a=0 q 0
 s sign=1
 i a<0 s sign=sign*(-1),a=-a
 i b<0 s sign=sign*(-1),b=-b
 i a'["." s a=a_"."
 s x=0
 i b["." s x=$l($p(b,".",2)),b=$p(b,".",1)_$p(b,".",2)
 f i=1:1:x s n=$p(a,".",2) s:n="" n=0 s a=$p(a,".",1)_$e(n,1)_"."_$e(n,2,255)
 s signif=0,done=0,r="",c="" f i=1:1:100 d divide2 q:done
 q (sign*r)
divide2 
 s x=$e(a,1),a=$e(a,2,255) i x="." s r=r_x g divide2
 s c=c_+x,n=0
sub  
 s x=c-b i (x>0)!(x=0) s n=n+1,c=x g sub
 s r=r_n i signif s signif=signif+1
 e  i n'=0 s signif=1
 i (signif>19)!((c=0)&(a=0)) s done=1
 q
  
  
 ;----------------------------------------------------------------------------
 ; Transcendental functions
  
Rad(d)  
 ; Convert decimal degrees "d" to radians
 q (d/180*3.14159265358979323846)
  
Deg(r)  
 ; Convert radians "r" to decimal degrees
 q (r/3.14159265358979323846*180)
  
Sin(x)  
 ; Sin - "x" must be in radians
 i x<0 q ($$sincos(x,-x,-1,0))
 q ($$sincos(x,x,1,0))
  
Cos(x)  
 ; Cos - "x" must be in radians
 n y
 s y=x i x<0 s y=-y
 s y=y+1.57079632679489661923                    ; pi/2
 q ($$sincos(x,y,1,1))
  
sincos(x,y,sign,getcos) 
 n n,xn,f,x1,x2,c1,c2,t,g,rg,r1,r2,r3,r4,r5,r6,r7,r8
 d setup1
 i y>314159265358979323846 s y=y/100000000
 s (n,xn)=$$rndint(y*0.31830988618379067154)     ; y * 1/pi
 i n#2 s sign=-sign
 i getcos s xn=xn-.5
 s f=x i x<0 s f=-f
 s x1=$$trnint(f)
 s x2=f-x1
 s c1=3.1416015625
 s c2=-0.000008908910206761537356617
 s f=((x1-(xn*c1))+x2)-(xn*c2)
 ; The following test to prevent underflow in r1*(f**3) is removed
 ; s t=f s:f<0 t=-f i t<0.0000000001 goto scsign
 s g=f*f
 s rg=g*(r1+(g*(r2+(g*(r3+(g*(r4+(g*(r5+(g*(r6+(g*(r7+(g*r8))))))))))))))
 s f=f+(f*rg)
scsign  
 i sign<0 s f=-f
 q (f)
  
rndint(x) 
 ; Round to integer
 i x<0 q (+$p(x-.5,".",1))
 q (+$p(x+.5,".",1))
  
trnint(x) 
 ; Truncate to integer
 q (+$p(x,".",1))
  
Sqrt(x) 
 ; Square Root
 n f,y0,i,exp
 i x=0 q (0)
 i x<0 s x=1-x
 s f=$$frexp(x)
 s y0=.223607+(.894427*f)
 f i=1:1:3 s y0=.5*(y0+(f/y0))
 s y0=y0+(.5*((f/y0)-y0))
 i exp#2 s exp=exp+1,y0=y0*.31622776601683793320 ; y0=y0*sqrt(1/10)
 s y0=$$ldexp(y0,exp/2)
 q (y0)
  
ldexp(x,exp) 
 n i
 i exp>0 f i=1:1:exp s x=x*10
 i exp<0 f i=-1:-1:exp s x=x/10
 q (x)
  
frexp(x) 
 s exp=0 i x=0 q (0)
 i ((x>1)!(x=1)) f exp=1:1:100 s x=x/10 q:x<1
 i x<.1 f exp=-1:-1:-100 s x=x*10 q:((x>.1)!(x=.1))
 q (x)
  
ArcSin(x) 
 ; ArcSin - the result is in radians
 n a,b,p1,p2,p3,p4,p5,q0,q1,q2,q3,q4,q5,res,i
 d setup2
 s res=$$asincos(x,0)
 s res=(a(i)+res)+a(i)
 i x<0 s res=-res
 q (res)
  
ArcCos(x) 
 ; ArcCos - the result is in radians
 n a,b,p1,p2,p3,p4,p5,q0,q1,q2,q3,q4,q5,res,i
 d setup2
 s res=$$asincos(x,1)
 i x<0 s res=(b(i)+res)+b(i)
 e  s res=(a(i)-res)+a(i)
 q (res)
  
asincos(x,flag) 
 n y,g,pg,qg
 s y=x
 i x<0 s y=-y
 i y>.5 g gtr
 s i=flag
 ; The following test to avoid underflow in g=y*y is removed
 ; i y<0.0000000001 q (y)
 s g=y*y
 g cont
gtr  
 i y>1,(y-1)<0.000000000000000009 s y=1
 i y>1 s y=.5
 s i=1-flag
 s g=((.5-y)+.5)/2
 s y=-2*$$Sqrt(g)
cont  
 s pg=g*(p1+(g*(p2+(g*(p3+(g*(p4+(g*p5))))))))
 s qg=q0+(g*(q1+(g*(q2+(g*(q3+(g*(q4+g))))))))   ; avoids * by q5 (=1.0)
 s y=y+(y*(pg/qg))
 q (y)
  
Tan(x)  
 ; Tan - "x" must be in radians
 n p0,p1,p2,p3,q0,q1,q2,q3,q4,y,n,xn,x1,x2,c1,c2,f,t,g,xnum,xden
 d setup3
 s y=x i x<0 s y=-y
 i y>1570796326 s y=y/1000
 s (n,xn)=$$rndint(x*0.63661977236758134308)     ; x * 2/pi
 s x1=$$trnint(x)
 s x2=x-x1
 s c1=1.57080078125
 s c2=-0.000004454455103380768678308
 s f=((x1-(xn*c1))+x2)-(xn*c2)
 ; The following test to prevent underflow in p1*(f**3) is removed
 ; s t=f s:f<0 t=-f i t<0.0000000001 s xnum=f,xden=1 goto tancont
 s g=f*f
 s xnum=f+(f*g*(p1+(g*(p2+(g*p3)))))
 s xden=.5+.5+(g*(q1+(g*(q2+(g*(q3+(g*q4)))))))
tancont 
 i n#2 s xnum=-xnum,x=xden/xnum
 e  s x=xnum/xden
 q (x)
  
ArcTan(x) 
 ; ArcTan - the result is in radians
 n a,p0,p1,p2,p3,q0,q1,q2,q3,q4,f,n,t,s,A,g,pg,qg
 d setup4
 s f=x i x<0 s f=-x
 i f>1 s f=1/f,n=2
 e  s n=0
 s t=0.26794919243112270647                      ; 2 - sqrt(3)
 s s=1.73205080756887729353                      ; sqrt(3)
 s A=0.73205080756887729353                      ; sqrt(3) - 1
 i f>t s f=((((A*f)-0.5)-0.5)+f)/(s+f),n=n+1
 ; The following test to prevent underflow is removed
 ; s t=f s:f<0 t=-f i t<0.0000000001 goto polyskp
 s g=f*f
 s pg=g*(p0+(g*(p1+(g*(p2+(g*p3))))))
 s qg=q0+(g*(q1+(g*(q2+(g*(q3+g))))))            ; Note: q4=1
 s f=f+(f*(pg/qg))
polyskp 
 i n>1 s f=-f
 s f=f+a(n)
 i x<0 s f=-f
 q (f)
setup1  
 ; for Sin & Cos labels
 s r1=-0.16666666666666665052
 s r2=0.0083333333333331650314
 s r3=-0.00019841269841201840457
 s r4=0.0000027557319210152756119
 s r5=-0.000000025052106798274584544
 s r6=0.00000000016058936490371589114
 s r7=-0.00000000000076429178068910467734
 s r8=0.0000000000000027204790957888846175
 q
  
setup2  
 ; for ArcSin & ArcCos labels
 s a(0)=0
 s a(1)=0.78539816339744830962                   ; pi/4
 s b(0)=1.57079632679489661923                   ; pi/2
 s b(1)=a(1)
 s p1=-27.368494524164255994
 s p2=57.208227877891731407
 s p3=-39.688862997504877339
 s p4=10.152522233806463645
 s p5=-0.69674573447350646411
 s q0=-164.21096714498560795
 s q1=417.14430248260412556
 s q2=-381.86303361750149284
 s q3=150.95270841030604719
 s q4=-23.823859153670238830
 s q5=1
 q
  
setup3  
 ; for Tan label
 s p0=1
 s p1=-0.13338350006421960681
 s p2=0.0034248878235890589960
 s p3=-0.000017861707342254426711
 s q0=1
 s q1=-0.46671683339755294240
 s q2=0.025663832289440112864
 s q3=-0.00031181531907010027307
 s q4=0.00000049819433993786512270
 q
  
setup4  
 ; for ArcTan label
 s a(0)=0
 s a(1)=0.52359877559829887308                   ; pi/6
 s a(2)=1.57079632679489661923                   ; pi/2
 s a(3)=1.04719755119659774615                   ; pi/3
 s p0=-13.688768894191926929
 s p1=-20.505855195861651981
 s p2=-8.4946240351320683534
 s p3=-0.83758299368150059274
 s q0=41.066306682575781263
 s q1=86.157349597130242515
 s q2=59.578436142597344465
 s q3=15.024001160028576121
 s q4=1
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^Math("error")=$ze
 g ^%ETN
 q
  

OSC.INT.1.58643,54975.
OSC                                 ; revised by MDS, 7/24/97
 w !
 w "OSC",!
 w "---",!
 w "OSC is a test which was given to Quality Assurance by OSC Corporation.",!
 w "The test was subsequently converted into a suite consisting of two jobs,",!
 w "OSCEdge and OSCIns.  However, no one knows what the point of the suite",!
 w "was.  And the legend continues.",!
 w "This appears to be a 'global' test, which means that it tests the global",!
 w "module.  It also appears that the OSCEdge and OSCIns jobs interract.",!
 w "Therefore, you should start at least one of each.",!
 w !
 w "Please use Start^OSC(edgeJobs,insertJobs) to start this test.",!
 w "edgeJobs   = number of OSCEdge jobs",!
 w "insertJobs = number of OSCIns jobs",!
 w "The default values will start a minimal meaningful test.",!
 q
  
Start(edgeJobs,insertJobs,limit)                 ;AFH 07/23/01 add limit parameter        
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^OSC) Destroy
 s edgeJobs=$g(edgeJobs,1)
 s insertJobs=$g(insertJobs,1)
 s limit=$g(limit,100)*1000000\(edgeJobs+insertJobs)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With edgejobs="_edgeJobs_" insertJobs="_insertJobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^OSC("PID")=edgeJobs+insertJobs
 f i=1:1:edgeJobs j OSCEdge(limit)
 f i=1:1:insertJobs j OSCIns(limit)
 ;f i=1:1:edgeJobs d OSCEdge(limit)
 ;f i=1:1:insertJobs d OSCIns(limit)
 q
  
Status() 
 ; Check activity in the CPU for OSC jobs
 q $$Status^Library("1""OSC""",2,60,"^OSC(""PID"")")
  
Stop 
 ; Stops all currently running OSC jobs using their PIDs
 d Stop^Library("^OSC(""PID"")",30)
 q
  
Result() 
 n status
 q:$d(^OSC("error")) "FAIL -- "_^OSC("error")
 q:$d(^OSC)=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by ^OSC routine
 i $d(^OSC),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^osc
 k ^OSC
 q
  
OSCEdge(limit) 
 s load=0
 s $zt="errorTrap"                       ; Sets error trap
 s ^OSC("PID",$J)=""                     ; Records job numbers
 i $zu(9,"",$zn_" Edge Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 ; New Variables
 n G                                     ; Global reference to use (path to ^GBDEBTOR)
 n c                                     ; Count
 n a                                     ; Test variable
 n x                                     ; Random number
 ; Initialize Variables
 s G="^osc"
 s c=0
 ; Perform test
 f  d
 .  l +@G
 .  s:'$G(@G) @G=200000
 .  s a=@G,@G=a+1
 .  l -@G
 .  s c=c+10
 .  s:c>80 c=10
 .  i c=80 s c=80,@G@(a,c)=0 d load ;AFH 07/23/01 add limit parameter     
 .  i c=20 d
 .  .  s x=$R(3)
 .  .  f i=1:1:x s @G@(a,c,i)=$$str(400) d load ;AFH 07/23/01 add limit parameter     
 .  i c=30 d
 .  .  s x=$R(3)
 .  .  f i=1:1:x s @G@(a,c,i)=$$str(80) d load ;AFH 07/23/01 add limit parameter     
 .  s @G@(a,c,1)=$$str(70)
 .  d load ;AFH 07/23/01 add limit parameter     
 q
  
OSCIns(limit)
 s load=0        
 s $zt="errorTrap"                       ; Sets error trap
 s ^OSC("PID",$J)=""                     ; Records job numbers
 i $zu(9,"",$zn_" Ins Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 ; New Variables
 n G                                     ; Global reference to use (path to ^GBDEBTOR)
 n a
 n l
 n x
 ; Perform Initial Hang
 h $R(50)
 s G="^osc"
 ; Perform Test
 f  d
 .  s x=$R(4)+1
 .  s a=$G(@G)-$O(@G@(""))\x
 .  s a=a+200000
 .  q:'$D(@G@(a))
 .  l +@G@(a)
 .  s l=$zp(@G@(a,20,"")),^(l+1)=$$str(500) d load ;AFH 07/23/01 add limit parameter     
 .  s x=$R(4)
 .  f i=1:1:x s l=$zp(@G@(a,30,"")),^(l+1)=$$str(80) d load ;AFH 07/23/01 add limit parameter     
 .  l -@G@(a)
 q
  
str(len) 
 ;q $R(999999)  ; Commented this out because it disables a significant portion of the test.
 n x,s
 s x=len\2,x=x+$r(x),s=""
 d:'$d(z) zset
 f i=1:1:510 s s=s_z($r(90)+1)
 q $e(s,1,x)
  
zset 
 n i
 f i=35:1:125 s z(i-34)=$C(i)
 q
 
load ;AFH 07/23/01 add limit parameter     
 n a,b
 s a=$l($zr),b=$l(@$zr),load=$g(load)+a+b
 i load>limit l  l +@G k @G l -@G s load=0,^OSC("load")=$g(^OSC("load"))+1
 quit
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^OSC("error")=$ze
 g ^%ETN
 q
  
  

ReusePID.INT.1.58610,65257.
ReusePID                                  ; revised by MDS, 8/4/97
 ; Compiled 04/23/96 01:43PM for M/WNT
 w !
 w "ReusePID",!
 w "--------",!
 w "ReusePID will use up as many PID numbers as possible.  In the past,",!
 w "problems have occurred when PID numbers are reused.  Therefore, the",!
 w "idea is to use up as many PID numbers as possible.",!
 w !
 w "Please use Start^ReusePID(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value will start a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^ReusePID) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^ReusePID("started")=0
 s ^ReusePID("PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for ReusePID jobs
 ; slowTime is 2 seconds more than timeout on the job command
 ; deadTime is a large value, since this test grows fast with number of jobs
 q $$Status^Library("1""ReusePID""",17,45,"^ReusePID(""PID"")")
  
Stop 
 ; Stops all currently running ReusePID jobs using their PIDs
 n start
 s ^ReusePID("stop")=""
 s start=$$zh^Library
 f  q:($$zh^Library-start)>45  q:$e($$Status,1,17)="OK -- Not running"
 q
  
Result() 
 n status,pid,used,finished,started,result
 q:$d(^ReusePID("error")) "FAIL -- "_^ReusePID("error")
 q:$d(^ReusePID)=0 "FAIL -- Test data are missing."
 s finished=0
 s used=0
 s pid=$o(^ReusePID("used",""))
 f  q:pid=""  d
 .  s finished=finished+^ReusePID("used",pid)
 .  s used=used+1
 .  s pid=$o(^ReusePID("used",pid))
 s started=$g(^ReusePID("started"),0)
 s result="Started="_started_"   Finished="_finished_"   PIDs used="_used_$c(13,10)
 q:finished<(started*0.75) result_"FAIL -- Less than 75% of the jobs started"
 s status=$$Status
 i $e(status,1,17)="OK -- Not running" d  q result
 .  s:used<finished result=result_"PASS"
 .  s:used=finished result=result_"PASS -- However, no PIDs were reused."
 .  s:used>finished result=result_"FAIL -- test statistics are incoherent"
 q:$e(status,1,2)="OK" result_"FAIL -- Still running."
 q result_"FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by ^ReusePID routine
 i $d(^ReusePID),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^ReusePID
 q
  
Run 
 ; Initialize Variables
 s $zt="errorTrap"                       ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^ReusePID("PID",$j)=""                  ; Records job numbers
 s ^ReusePID("count",$j)=0
 ; Perform test
 f  q:$d(^ReusePID("stop"))  d
 .  ; Ensure not too many jobs are running at once
 .  f  q:+$G(^ReusePID("count",$j))<10  d
 .  .  h 1  ; By putting this hang on a separate line, we ensure that the job does not appear "DEAD".
 .  ; Start new job
 .  l ^ReusePID("count",$j)
 .  s ^ReusePID("count",$j)=^ReusePID("count",$j)+1
 .  l
 .  j NewJob($j)
 .  ; We don't check $t here, because on a heavily loaded system it is unreliable.
 .  ; Instead, we will use a statistical check in Result() to verify if jobs are starting.
 .  l ^ReusePID("started")
 .  s ^ReusePID("started")=^ReusePID("started")+1
 .  l
 k ^ReusePID("PID",$j)
 l ^ReusePID("PID")
 s ^ReusePID("PID")=+$g(^ReusePID("PID"))-1
 q
  
NewJob(PID) 
 s $zt="errorTrap"                       ; Sets error trap
 l ^ReusePID("used",$j)
 s ^ReusePID("used",$j)=$g(^ReusePID("used",$j))+1
 l
 ; Since we intend to die now, decrement process count
 l ^ReusePID("count",PID)
 s ^ReusePID("count",PID)=^ReusePID("count",PID)-1
 l
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^ReusePID("error")=$ze
 g ^%ETN
 q
  
  

SetMany.INT.1.58610,65257.
SetMany ;
 ;
 ; 07/24/97 MDS Revised routine. 
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "SetMany",!
 w "-------",!
 w "SetMany stress the M global module.  It continually sets and kills many",!
 w "different globals.",!
 w !
 w "Please use Start^SetMany(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value will start a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^SetMany($zu(86),"PID")) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^SetMany($zu(86),"PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for SetMany jobs
 q $$Status^Library("1""SetMany""",2,15,"^SetMany("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops currently running SetMany jobs using their PIDs
 d Stop^Library("^SetMany("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
  
Result() 
 n status
 q:$d(^SetMany($zu(86),"error")) "FAIL -- "_^SetMany($zu(86),"error")
 q:$d(^SetMany($zu(86)))=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by SetMany routine
 n G
 i $d(^SetMany($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 f i=0:1:99 s G="^setMany"_i k @G
 k ^SetMany($zu(86))
 q
  
Run 
 s $zt="errorTrap"                    ; Sets error trap
 s ^SetMany($zu(86),"PID",$J)=""         ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 ; New Variables
 n G
 f  d
 .  s G="^setMany"_$R(100)
 .  s @G=""
 .  k @G
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^SetMany($zu(86),"error")=$ze
 g ^%ETN
 q
  
  

SetOne.INT.1.58610,65257.
SetOne ;
 ;
 ; Continually SETs and KILLs the same global
 ;
 ; 07/24/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "SetOne",!
 w "------",!
 w "SetOne starts a user defined number of jobs, each of which continuously SETs",!
 w "a global and then KILLs it.  The global is set to the jobs job number ($J).",!
 w !
 w "Please use Start^SetOne(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value starts a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^SetOne($zu(86),"PID")) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^SetOne($zu(86),"PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for SetOne jobs
 q $$Status^Library("1""SetOne""",2,15,"^SetOne("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops currently running SetOne jobs using their PIDs
 d Stop^Library("^SetOne("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
  
Result() 
 n status
 q:$d(^SetOne($zu(86),"error")) "FAIL -- "_^SetOne($zu(86),"error")
 q:$d(^SetOne($zu(86)))=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by SetOne routine
 i $d(^SetOne($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^setOneGlobal
 k ^SetOne($zu(86))
 q
  
Run 
 s $zt="errorTrap"                    ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^SetOne($zu(86),"PID",$J)=""          ; Records job numbers
 ; New variables
 n G                             ; Large global reference
 ; Initialize variables
 s G="^setOneGlobal"
 ; Perform test
 f  d
 .  s @G=$J
 .  k @G
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^SetOne($zu(86),"error")=$ze
 g ^%ETN
 q
  
  

Setter.INT.1.58610,65257.
Setter ;
 ; Stresses the Write daemon and data and pointer block allocation
 ;
 ; 07/24/97 MDS Revised routine.
 ; 01/23/01 OS  Added optional third parameter (subLen) to Start tag that specifies
 ;                   the approximate subscript length.  This must be below 255 before
 ;                   Cache 4.1 (default is 200) and should be 500 or greater on
 ;                   Cache 4.1 (default is 500).
 ; 02/13/01 OS  Changed calculation of big database status to handle Cache versions
 ;                   less than 4.0 (uses bit 21 of $zv(0) which was undefined before
 ;                   Cache 4.0 and this caused <FUNCTION> error and infinite loop) 
 ; 02/20/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "Setter",!
 w "------",!
 w "Each Setter job sets many nodes, with a large number of subscripts, in the",!
 w "same global (^SetterGlobal).  Setter caused degradation in M/SQL-Unix 4.5.",!
 w !
 w "Please use Start^Setter(jobs,limit,subLen) to start this test.",!
 w "jobs  = number of jobs to start",!
 w "limit = maximum total global storage for all jobs (Mb)",!
 w "subLen = total length of subscript",!
 w "The default value starts a minimal meaningful test.",!
 q
  
Start(jobs,limit,subLen) ; OS-293
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^Setter($zu(86),"PID")) Destroy
 s jobs=$g(jobs,1)
 s limit=$g(limit,10)
 s subLen=$g(subLen,$Select($$IsBigDB():500,1:200))
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs_" limit="_limit)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 n nodes
 s nodes=limit*4000\jobs     ; 4000 = One million / approx size of node
 s ^Setter($zu(86),"PID")=jobs
 f i=1:1:jobs j Run(nodes,subLen) ;OS-293
 q
  
Status() 
 ; Check activity in the CPU for Setter jobs
 q $$Status^Library("1""Setter""",2,15,"^Setter("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops currently running Setter jobs using their PIDs
 d Stop^Library("^Setter("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
  
Result() 
 n status
 q:$d(^Setter($zu(86),"error")) "FAIL -- "_^Setter($zu(86),"error")
 q:$d(^Setter($zu(86)))=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS -- Run DB diagnostics (^INTEGRIT and ^DIAG)."
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by Setter routine
 i $d(^Setter($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^setterGlobal
 k ^Setter($zu(86))
 q
  
Run(nodes,subLen) ; OS-293
 s $zt="errorTrap"                    ; Sets error trap
 s ^Setter($zu(86),"PID",$J)=""          ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 ; New variables
 n i
 n G                             ; Global reference
 n Global ; OS-293
 n node,Count
 ; n a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
 ; Initialize variables
 ;s G="^setterGlobal("_$j_")" ; OS-293 -
 s G="^setterGlobal" ; OS-293 +
 ; i $zu(72,0,67)  ; Don't know what this does or why it was here.
 ; Perform Test
 f  d
 .  f node=1:1:nodes d
 .  .  ; f Count=97:1:122 s @($C(Count))=$R(10000000) ; OS-293
 .  .  s Global=$$GenSS(G,subLen,8,5,"I")
 .  .  ; s @G@(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,x,y,z)=$R(10000000) ; OS-293 -
 .  .  s @Global=$R(10000000) ; OS-293 +
 .  k @G@($j) ; OS-293
 q
  
 ; GenSS is used to generate global with subscripts.
 ; GloName - Name of the global (ex.,"^a")
 ; SSLen - Total length of subscripts (ex.,200)
 ; MxSSLen - Max length of single subscript (ex.,20).
 ; MnSSLen - Min length of single subscript (ex.,5).
 ; SSType - Subscript type, it can be either string - "S", or integer - "I"
 ; if SSType="I"  then Actual_Length_Subscript=$L(RADIX_100(Subscript_Value))
 ; The total length of subscripts=
 ; length of the global name +
 ; lengths of all subscripts +
 ; number of subscripts +
 ; number of numeric subscripts ;
GenSS(GloName,SSLen,MxSSLen,MnSSLen,SSType)  
 n last,SS,subLen
 s last=0
 s SS=GloName_"("_$j_","
 s SSLen=SSLen-$L(GloName)+1-$L($$EncodeSS($j))
 for  q:last  q:SSLen'>0  d
 . s subLen=MnSSLen+$R(MxSSLen-MnSSLen)
 . if (SSLen-subLen)'>0 d
 . . s:SSType="S" subLen=$Select(SSLen#2=0:SSLen,1:(SSLen+1))
 . . if SSType'="S" d
 . . . s subLen=$S(MnSSLen>SSLen:MnSSLen,1:SSLen)
 . . . if subLen#2'=0 s subLen=subLen+1
 . . . s subLen=(subLen/2)+1
 . . s last=1
 . s Subscript=$$PreSS(SSType,subLen)
 . s SSLen=SSLen-$Select(SSType="S":subLen,SSType'="S":$L($$EncodeSS(Subscript)))-1-$Select(SSType="I":1,1:0)
 . s SS=SS_Subscript_"," ; OS-292
 s $e(SS,$l(SS))="" ; OS-292+
 q SS_")"
PreSS(SSType,subLen) 
 n SubScript,i
 s SubScript=""
 s:SSType="NI" SubScript="-"
 for i=1:1:subLen d
         . s:SSType="S" SubScript=SubScript_$C($A("a")+$R(26))
         . if (SSType="I") s SubScript=SubScript_$C($A("1")+$R(9))
 s:SSType="S" SubScript=""""_SubScript_""""
 q SubScript
EncodeSS(n) 
 n descriptor
 n decPos ; decimal point position
 s decPos=$l(n)
 if decPos#2 do
 . s decPos=decPos+1
 . s n="0"_n
 if n#1 zt "UE" ; FIXME
 if (n<2)&(n'<1) s descriptor=18 g l1
 if n>(2**63) zt "UE"
 if n>1 s descriptor=decPos/2+18
 if n<-1 s descriptor=decPos/2+3
l1 n i,ret
 s ret=""
 for i=1:2:$l(n) s %=$e(n,i,i+1) s ret=ret_$c(%+28)
 q $c(descriptor)_ret
 ;
IsBigDB() 
 q $$zBitGet^Library(21)
 ;
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^Setter($zu(86),"error")=$ze
 g ^%ETN
 q
  

TTYHash.INT.1.58610,65257.
TTYHash ;
 ; 07/09/97 MDS Revised routine.
 ; 01/11/01 AFH Changed the default connection port from 9 to 23 (the
 ;                   standard telnet port).
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "TTYHash",!
 w "-------",!
 w "TTYHash is a test which stresses the hash table.  A user specified number of",!
 w "TTYHash jobs are jobbed off in the background.  Each job take turns opening",!
 w "a terminal device.  The device must be a valid terminal device which is NOT",!
 w "currently running a Cache session.  Since this test involves contention for",!
 w "a device, it is only meaningful if you run at least two jobs.",!
 w !
 w "Please use Start^TTYHash(jobs,device) to start this test.",!
 w "jobs       = the number of jobs to start (default = 2)",!
 w "device     = the IO device to use        (default = |TCP|23)",!
 w "parameters = any parameters specific to the IO device (optional)",!
 w "The defaults start a minimal meaningful test.",!
 q
  
Start(jobs,device,parameters) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^TTYHash($zu(86),"PID")) Destroy
 s jobs=$g(jobs,2)
 d:$d(device)=0
 .  s device="|TCP|23"
 .  s parameters="(""127.0.0.1""::""M"")"
 s parameters=$g(parameters,"")
 s ^TTYHash($zu(86),"jobs")=jobs
 s ^TTYHash($zu(86),"PID")=jobs
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs_" device="_device_" parameters="_parameters)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 f i=1:1:jobs j Run(device,parameters)
 q
  
Status() 
 ; Check activity in the CPU for BlockSplit and BSQuery jobs
 ; slowTime is a little longer than the timeout of the open command in Run().
 ; deadTime is roughly 15 seconds longer than slowTime
 q $$Status^Library("1""TTYHash""",32,45,"^TTYHash("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops all currently running BlockSplit and BSQuery jobs using their PIDs
 d Stop^Library("^TTYHash("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
  
Result() 
 n sum,job,mean,fail,status
 q:$d(^TTYHash($zu(86),"error")) "FAIL -- "_^TTYHash($zu(86),"error")
 q:$d(^TTYHash($zu(86)))=0 "FAIL -- Test data are missing."
 ; Since this is a contention test, we check if any one job is getting more
 ; (or less) than its share.  We arbitrarily choose 13% as the maximum
 ; variation.
 s sum=0
 s job=$o(^TTYHash($zu(86),"open",""))
 f  q:job=""  d
 .  s sum=sum+^TTYHash($zu(86),"open",job)
 .  s job=$o(^TTYHash($zu(86),"open",job))
 s mean=sum/^TTYHash($zu(86),"jobs")
 s fail=0
 s job=$o(^TTYHash($zu(86),"open",""))
 f  q:job=""  q:fail  d
 .  i $zabs(^TTYHash($zu(86),"open",job)/mean-1)>0.13 s fail=1 q
 .  s job=$o(^TTYHash($zu(86),"open",job))
 q:fail "FAIL -- At least one job had more (or less) than its share of access"
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS"
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by TTYHash routine
 i $d(^TTYHash($zu(86))),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^TTYHash
 q
  
Run(device,parameters) 
 s $zt="errorTrap"                    ; Sets error trap
 s ^TTYHash($zu(86),"PID",$J)=""         ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s argument=""""_device_""":"_parameters_":30"
 ; Perform test
 f  d
 .  o @argument
 .  d:$t
 .  .  s ^TTYHash($zu(86),"open",$j)=$g(^TTYHash($zu(86),"open",$j))+1
 .  .  u device
 .  .  w !,"Test output from job #"_$J,!
 .  .  c device
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 s ^TTYHash($zu(86),"error")=$ze
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 g ^%ETN
 q
  

TailChase.INT.1.58610,65257.
TailChase       ;
 ; 
 ; TailChase was originally part of the Pull The Plug Demo, written by Lee
 ; Mesnekoff for Sales.
 ;
 ; 05/28/92 LM  This should be run after the routine TailChas.  It will
 ;                   check to see if MUMPS has preserved the proper time
 ;                   ordering in the setting and killing of the global
 ;                   ^TCxxxx, where xxxx is the job number of the
 ;                   originating suite.
 ; 06/07/93 JPD Took code from the "Pull the plug" demo to create a
 ;                   separate suite called TailChas.  This caused database
 ;                   degradation on the rs6000 because write image
 ;                   journalling caught part of a rebuild being performed
 ;                   on the TailChas global (when the head node was
 ;                   killed, it had to rebuild the tree).  For best
 ;                   results, run TailChas to create global activity when
 ;                   you are running the write image journalling test plan.
 ; 08/04/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "TailChase",!
 w "---------",!
 w "TailChase works by setting nodes sequentially to an integer value",!
 w "that keeps counting up.  Meanwhile, it kills the nodes that are more than",!
 w "1000 behind the current node.  The tail end is always 1000 behind the head,",!
 w "thus 'chasing' it.  TailChase also associates a time stamp with each node.",!
 w !
 w "TailChase was originally part of the Pull The Plug Demo.  To make this test",!
 w "more effective, you should actually pull the plug while it is running.",!
 w !
 w "The verification phase of this test will walk through each of the ^tailChase#",!
 w "globals (where # is integer >= 1) and check for the following:",!
 w "     Nodes are contiguous",!
 w "     Nodes are in time order",!
 w "     The contents of the node agrees with its subscripts",!
 w "     There are no more than 1000 nodes",!
 w "A failure of any of these points indicates a failure of Write Image Journaling.",!
 w !
 w "Please use Start^TailChase(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value starts a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                       ; Sets error trap
 d:$d(^TailChase($zu(86),"PID")) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^TailChase($zu(86),"jobs")=jobs
 s ^TailChase($zu(86),"PID")=jobs
 f i=1:1:jobs j Run(i)
 q
  
Status() 
 ; Check activity in the CPU for TailChase jobs
 q $$Status^Library("1""TailChase""",2,15,"^TailChase("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops all currently running TailChase jobs using their PIDs
 d Stop^Library("^TailChase("_$c(34)_$zu(86)_$c(34)_",""PID"")",30)
 q
  
Result() 
 ; In this test, we expect jobs to appear crashed, since the system may
 ; have been unplugged.  Therefore, we will not check for jobs status,
 ; except to see if they are still running.
 n status,result,sub1,sub2,sub1next,sub2next,time,nextTime,global,count
 s $zt="ResultError"
 q:$d(^TailChase($zu(86),"error")) "FAIL -- "_^TailChase($zu(86),"error")
 q:$d(^TailChase($zu(86)))=0 "FAIL -- Test data are missing."
 s status=$$Status
 q:($e(status,1,2)="OK")&($e(status,1,17)'="OK -- Not running") "FAIL -- Still running."
 s result=""
 f instance=1:1:$g(^TailChase($zu(86),"jobs")) q:result'=""  d
 .  s global="^tailChase"_instance
 .  s sub1=$o(@global@(""))
 .  f count=1:1:1000 q:sub1=""  q:result'=""  d
 .  .  s sub2=$o(@global@(sub1,""))
 .  .  i $p(@global@(sub1,sub2),"#",2)'=sub1 s result="FAIL -- Node value doesn't agree with subscript: "_global_"("_sub1_")" q
 .  .  s sub1next=$o(@global@(sub1))
 .  .  d:sub1next'=""
 .  .  .  i sub1next'=(sub1+1) s result="FAIL -- Nodes are not contiguous: "_global_"("_sub1next_")" q
 .  .  .  s sub2next=$o(@global@(sub1next,""))
 .  .  .  s time=$p(sub2,",",1)*86400+$p(sub2,",",2)
 .  .  .  s nextTime=$p(sub2next,",",1)*86400+$p(sub2next,",",2)
 .  .  .  i time>nextTime s result="FAIL -- Nodes are not in time order: "_global_"("_sub1next_")" q
 .  .  s sub1=$o(@global@(sub1))
 .  i result="",sub1'="" s result="FAIL -- More than 1000 nodes: "_global q
 q:result'="" result
 q "PASS"
ResultError 
 s $zt="^%ETN"
 q "FAIL -- Error while checking: "_$ze
  
Destroy 
 ; Kills all globals formed by ^TailChase routine
 n i,max
 i $d(^TailChase($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 s max=$g(^TailChase($zu(86),"jobs"),50)
 f i=1:1:max k @("^tailChase"_i)
 k ^TailChase($zu(86))
 q
  
Run(instance) 
 s $zt="errorTrap"                       ; Sets error trap
 s ^TailChase($zu(86),"PID",$J)=""                ; Records job numbers
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s G="^tailChase"_instance
 ; Perform Test
 f Index=1:1:1000 d                      ; Initial 1000 nodes
 .  s @G@(Index,$H)="This is global node #"_Index
 f Index=1001:1 d                        ; Nodes 1001 through infinity
 .  k @G@(Index-1000)
 .  s @G@(Index,$H)="This is global node #"_Index
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^TailChase($zu(86),"error")=$ze
 g ^%ETN
 q
  
  

Viewer.INT.1.58610,65257.
Viewer                                 ; revised by MDS, 7/24/97
 w !
 w "Viewer",!
 w "------",!
 w "Viewer continually traverses through the M PID table performing a $V(-1)",!
 w "on each process.  This has caused processes to receive segmentation faults",!
 w "in the past.",!
 w !
 w "Please use Start^Viewer(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value starts a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^Viewer) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^Viewer("PID")=jobs
 f i=1:1:jobs j Run
 q
  
Status() 
 ; Check activity in the CPU for Viewer jobs
 q $$Status^Library("1""Viewer""",2,15,"^Viewer(""PID"")")
  
Stop 
 ; Stops currently running Viewer jobs using their PIDs
 d Stop^Library("^Viewer(""PID"")",15)
 q
  
Result() 
 n status,result,job
 q:$d(^Viewer("error")) "FAIL -- "_^Viewer("error")
 q:$d(^Viewer)=0 "FAIL -- Test data are missing."
 i $d(^Viewer("anomoly")) d  q result
 .  s result="The following anomolies occurred:"_$c(13,10)
 .  s job=$o(^Viewer("anomoly",""))
 .  f  q:job=""  d
 .  .  s result=result_^Viewer("anomoly",job)_$c(13,10)
 .  .  s job=$o(^Viewer("anomoly",job))
 .  s result=result_"FAIL"
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" "PASS"
 q:$e(status,1,2)="OK" "FAIL -- Still running."
 q "FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by Viewer routine
 i $d(^Viewer),$e($$Status,1,17)'="OK -- Not running" d Stop
 k ^Viewer
 q
  
Run 
 s $zt="errorTrap"                    ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^Viewer("PID",$J)=""          ; Records job numbers
 ; Variables:
 ;    Data      Returned by $V(-1)
 ;    Job       Current job being evaluated
 f  d      ; Create a new stack level to absorb <NOJOB> errors, a frequent condition.
 .  s $zt="errorTrap"
 .  s Job=""
 .  f  d
 .  .  s Job=$zj(Job)
 .  .  s:Job="" Job=$ZJ(Job)
 .  .  s Data=$v(-1,Job)
 .  .  i $p(Data,"^",4)'="",$p(Data,"^",4)'?1.3N d
 .  .  .  s ^Viewer("anomoly",Job)="KB="_$p($v(-1,Job),"^",4)_"""    $v(-1,Job)="_Data_""""
 q
  
errorTrap 
 s $zt="^%ETN"
 q:$ze["<NOJOB"
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ZR=$ZR
 s ^Viewer("error")=$ze
 g ^%ETN
 q
  
  

ZBash.INT.1.58610,65257.
ZBash ;
 ;
 ; Jobs out a user-specified number of jobs, each of which randomly
 ; picks a routine name, ZINSERTs lines of code into the routine,
 ; ZSAVEs the routine, runs the routine, and ZREMOVEs the routine.
 ;
 ; 07/24/97 MDS Revised routine.
 ; 02/16/01 LSA Added "cluster aware" modifications from Al and Charles.
 ;                   The significant change is to add $zu(86) as a
 ;                   subscript to the control global. This is so it can
 ;                   keep track of which jobs it started as opposed to
 ;                   jobs started from other cluster nodes.
 ;
 w !
 w "ZBash",!
 w "-----",!
 w "ZBash stresses the building, running and deleting of routines.  Each ZBash job",!
 w "continuously does the following:",!
 w !
 w "         1)  ZI lines of code into a ranomly named routine",!
 w "         2)  ZS the routine",!
 w "         3)  Run the routine",!
 w "         4)  ZR the lines of code in the routine",!
 w !
 w "Please use Start^ZBash(jobs) to start this test.",!
 w "jobs = the number of jobs to start",!
 w "The default value starts a minimal meaningful test.",!
 q
  
Start(jobs) 
 s $zt="errorTrap"                    ; Sets error trap
 d:$d(^ZBash($zu(86),"PID")) Destroy
 s jobs=$g(jobs,1)
 i $zu(9,"",$zn_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2))_" With jobs="_jobs)
 i $zu(9,"",$zn_" $zu(49)="_$zu(49,""))
 s ^ZBash($zu(86),"PID")=jobs+1
 j fillAccept
 f  q:$$UnicodeLength^Library("^ZBash("_$c(34)_$zu(86)_$c(34)_"""accept"")")>96
 f i=1:1:jobs j Run
 q
  
Status() 
 q $$Status^Library("1(1""ZBash"",1""Library"",1"""",1""qa"".N1E)",2,15,"^ZBash("_$c(34)_$zu(86)_$c(34)_",""PID"")")
  
Stop 
 ; Stops currently running ZBash jobs using their PIDs
 d Stop^Library("^ZBash("_$c(34)_$zu(86)_$c(34)_",""PID"")",15)
 q
  
Result() 
 n status,result,accept,length,comma,i,last,current
 q:$d(^ZBash($zu(86),"error")) "FAIL -- "_^ZBash($zu(86),"error")
 q:$d(^ZBash($zu(86)))=0 "FAIL -- Test data are missing."
 s result=""
 s accept="^ZBash("_$c(34)_$zu(86)_$c(34)_"""accept"")"
 d:$d(@accept)
 .  s result="The following characters were disallowed in routine names:"_$c(13,10)
 .  s length=$$UnicodeLength^Library(accept)
 .  s last=-1
 .  s comma=""
 .  f i=1:1:length q:$l(result)>30000  d
 .  .  s current=$a($$UnicodeFetch^Library(accept,i))
 .  .  d:current-last>1
 .  .  .  s result=result_comma_(last+1)
 .  .  .  s:current-last>2 result=result_"-"_(current-1)
 .  .  .  s comma=", "
 .  .  s last=current
 .  i $l(result)'>30000,last<65535 d
 .  .  s:last=65534 result=result_comma_"65535"
 .  .  s:last<65534 result=result_comma_(last+1)_"-65535"
 .  s result=result_$c(13,10)
 .  s:$l(result)>30002 result=result_"Did not show all ranges.  Query ^ZBash($zu(86),""reject"") for a complete list."_$c(13,10)
 s status=$$Status
 q:$e(status,1,17)="OK -- Not running" result_"PASS"
 q:$e(status,1,2)="OK" result_"FAIL -- Still running."
 q result_"FAIL -- "_status
  
Destroy 
 ; Kills all globals formed by ZBash routine
 n name
 i $d(^ZBash($zu(86),"PID")),$e($$Status,1,17)'="OK -- Not running" d Stop
 s name=$o(^ROUTINE("qa"))
 f  q:$e(name,1,2)'="qa"  d
 .  k ^ROUTINE(name)
 .  k ^rOBJ(name)
 .  s name=$o(^ROUTINE("qa"))
 k ^ZBash($zu(86))
 q
  
Run 
 s $zt="errorTrap"               ; Sets error trap
 i $zu(9,"",$zn_" Job "_$j_" Started at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^ZBash($zu(86),"PID",$J)=""           ; Records job number
 s accept="^ZBash("_$c(34)_$zu(86)_$c(34)_"""accept"")"
 s $etrap="g RunTrap^ZBash"
 ; zr, zi, & zs must be in execute strings to keep from trashing the current routine
 s Save="zr  x Insert zs @routine(i)"
 s Insert="zi routine(i) f line=1:1:template(0) zi template(line)"
 s Remove="zr  zs @routine(i)"
 f line=1:1 s template(line)=$t(Template+line) q:template(line)=""
 s template(0)=line
 f  d
 .  l @accept
 .  s length=$$UnicodeLength^Library(accept)
 .  f i=1:1:20 s routine(i)="qa"_$j_$$UnicodeFetch^Library(accept,$r(length)+1)
 .  l
 .  f i=1:1:20 x Save
 .  f i=1:1:20 d:routine(i)'="" @(routine(i)_"^"_routine(i))
 .  f i=1:1:20 x:routine(i)'="" Remove
 q
RunTrap 
 s $ecode=""         ; Clear ANSI-style error condition
 s error=$e($ze,1,8)
 i (error="<SYNTAX>") d  q
 .  n character
 .  s character=$e(routine(i),$l(routine(i)))
 .  l @accept
 .  d UnicodeRemove^Library(accept,character)
 .  l
 .  s routine(i)=""
 g errorTrap
 q
  
fillAccept 
 s ^ZBash($zu(86),"PID",$j)=""
 s accept="^ZBash("_$c(34)_$zu(86)_$c(34)_"""accept"")"
 f i=0:1:65535 d
 .  l @accept
 .  d UnicodeAdd^Library(accept,$c(i))
 .  l
 ; The following two steps are "critical" code, in the sense that no other
 ; code that reads or manipulates the PID list should be running at the
 ; same time.  Otherwise, we may see bogus error messages.  I expect this
 ; job to end in 5-10 minutes, so the chances of getting the bogus reading
 ; are low.  To resolve the problem, the Status tag should be rewritten so
 ; that it maintains a lock on PID for the entire time it operates.
 l ^ZBash($zu(86),"PID")
 k ^ZBash($zu(86),"PID",$j)
 s ^ZBash($zu(86),"PID")=$g(^ZBash($zu(86),"PID"))-1
 q
  
errorTrap 
 s $zt="^%ETN"
 s ZR=$ZR
 i $zu(9,"",$zn_" Job "_$j_" Died at "_$zd(+$h)_" "_$zt($p($h,",",2)))
 s ^ZBash($zu(86),"error")=$ze
 g ^%ETN
 q
  
Template 
 n
 s $zt="errorTrap^ZBash"
 q



