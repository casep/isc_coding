<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (Red Hat Enterprise Linux for x86-64) 2015.2 (Build 664_3_16515U)" ts="2017-05-04 16:51:37">
<Class name="zCustom.TC.Task.BackupIntegrityCheck">
<Description>
Performs integrity checks on database names found in TrakCareDBList,
TrakCareLabDBList, TrakCareIntegDBList, and OtherDBList.
If none of the databases in a list can be successfully checked then it is
assumed that the task run was not meant to run for that list and no
error is reported.
The task can write to the CConsole log and/or send an email.
The email will contain an overview of the integrity checks and the 
actual consolidated integrity logs can be sent as an attachment.</Description>
<IncludeCode>EnsUtil</IncludeCode>
<Super>zCustom.TC.Task.GenericEmail</Super>
<TimeChanged>63336,39197.884777</TimeChanged>
<TimeCreated>63336,38279.174371</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/BackupIntegrityCheck.xml#1 $</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;
This is defined in subclasses.</Description>
<Type>STRING</Type>
<Default>Backup Integrity Check</Default>
</Parameter>

<Property name="TrakCareDBList">
<Description>
Comma seperated list of database names to check the integrity of.
Should only be a list related to TrakCare.  </Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="TrakCareLabDBList">
<Description>
Comma seperated list of database names to check the integrity of.
Should only be a list related to TrakCare Lab.  </Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="TrakCareIntegDBList">
<Description>
Comma seperated list of database names to check the integrity of.
Should only be a list related to TrakCare Integration Environment.  </Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="OtherDBList">
<Description>
Comma seperated list of database names to check the integrity of.
Should only be a list not related the other three categories of databases.  </Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="CConsoleLogLevel">
<Description><![CDATA[
The level of information to log to the cconsole.log file.
if 2 only severe messages are logged.  Severe messages include:
<li>"Unable to perform Backup Integrity Check Task: "_ tStatus
<br>
If 1, severe and warnings are logged.  Warnings include:
<li>"TrakCare Database Backup Integrity Check Task Failed: "_ tStatus
<li>"TrakCare Lab Database Backup Integrity Check Task Failed: "_ tStatus
<li>"TrakCare Integration Database Backup Integrity Check Task Failed: "_ tStatus
<li>"Miscellaneous Database Backup Integrity Check Task Failed: "_ tStatus
<li>"Failed to Send Backup Integrity Check Task Email With Attachment: "_ tStatus
<li>"Failed to Send Backup Integrity Check Task Email: "_ tStatus
<li>"Unable to get an array of databases using Config.Databases:List: "_ tStatus
<li>"Failed to copy "_pSource_" to "_pTarget_": "_ tStatus
<li>"Failed to mount  "_pDBDirectory_": "_ tStatus
<li>"Integrity check failed during the following database checks  "_pDBList_": "_ tStatus
<br>
If 0, severe, warning, and info messages are logged.  Info messages include:
<li>"Backup Integrity Check Task Started"
<li>"Sending Backup Integrity Check Task Email With Attachment"
<li>"Sending Backup Integrity Check Task Email"
<li>"Backup Integrity Check Task Completed"
<li>"Integrity Check Status: Database directory not found for: "_tDBName
<li>"Integrity Check for "_tDBName_":"_tDBDirectory_" successfully completed"]]></Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="AttachIntegrityLogs">
<Description>
If true the consolidated integrity check for the current task run will
be attached to the email.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="LogDirectory">
<Description>
The directory to create integration log files.
The file name is not configurable and only one log will ever exist to 
prevent this task from creating an endless run of integrity logs.</Description>
<Type>%String</Type>
</Property>

<Parameter name="LogFileName">
<Description>
The name of the consolidated integrity log file.</Description>
<Type>COSEXPRESSION</Type>
<Default>$TR($ZDT($H,3)," :-","")_"-DatabaseIntegrityCheck.log"</Default>
</Parameter>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Set tStatus = $$$OK
	Set tOrigNS = $ZU(5)
	Try{
		#;Prep final email stream and call integrity checks
		Set tReportStream = ##class(%Stream.TmpCharacter).%New()
		ZN "%SYS"
		Set tLogStatus = ..WriteToCConsole(0,"Backup Integrity Check Task Started")
		#;Manage file -- default and normalize directory 
		Set:(..LogDirectory="") ..LogDirectory = $ZU(168)  // set to mgr directory if null
		Set ..LogDirectory = ##class(%File).NormalizeDirectory(..LogDirectory)
		#;remove old logs if it exists -- allow only one log to prevent old logs lying around
		Do:(##class(%File).Exists(..LogDirectory_..#LogFileName)=1) ##class(%File).Delete(..LogDirectory_..#LogFileName)
		
		#;Get array of available db's defined in the cache.cpf
		Set tStatus = ..GetArrayOfDBs(.tDBArray)
		
		Set tStatus = ..CheckDBByListType(..TrakCareDBList,"TrakCare Database",tDBArray,.tReportStream)
		If ($$$ISERR(tStatus)) Set tLogStatus = ..WriteToCConsole(1,"TrakCare Database Backup Integrity Check Task Failed: "_ tStatus)
		Set tStatus = ..CheckDBByListType(..TrakCareLabDBList,"TrakCare Lab Database",tDBArray,.tReportStream)
		If ($$$ISERR(tStatus)) Set tLogStatus = ..WriteToCConsole(1,"TrakCare Lab Database Backup Integrity Check Task Failed: "_ tStatus)
		Set tStatus = ..CheckDBByListType(..TrakCareIntegDBList,"TrakCare Integration Database",tDBArray,.tReportStream)
		If ($$$ISERR(tStatus)) Set tLogStatus = ..WriteToCConsole(1,"TrakCare Integration Database Backup Integrity Check Task Failed: "_ tStatus)
		Set tStatus = ..CheckDBByListType(..OtherDBList,"Miscellaneous Database",tDBArray,.tReportStream)
		If ($$$ISERR(tStatus)) Set tLogStatus = ..WriteToCConsole(1,"Miscellaneous Database Backup Integrity Check Task Failed: "_ tStatus)

		/* For debugging only
		Do tReportStream.Rewind()
		While ('tReportStream.AtEnd){
			W tReportStream.Read()
		}
		//*/
		#;Switch back to the NS that has the tasks to ensure the email works
		#;If in %SYS and tasks are not in %SYS then Util.Email class is not found
		ZN tOrigNS
		If (..AttachIntegrityLogs=1){
			Set tLogStatus = ..WriteToCConsole(0,"Sending Backup Integrity Check Task Email With Attachment: "_..LogDirectory_..#LogFileName)
			Set tStatus = ..SendEmail(tReportStream,..LogDirectory_..#LogFileName)
			If ($$$ISERR(tStatus)) Set tLogStatus = ..WriteToCConsole(1,"Failed to Send Backup Integrity Check Task Email With Attachment("_..LogDirectory_..#LogFileName_"): "_ tStatus)
		}Else{
			Set tLogStatus = ..WriteToCConsole(0,"Sending Backup Integrity Check Task Email")
			Set tStatus = ..SendEmail(tReportStream)
			If ($$$ISERR(tStatus)) Set tLogStatus = ..WriteToCConsole(1,"Failed to Send Backup Integrity Check Task Email: "_ tStatus)
		}
		Set tLogStatus = ..WriteToCConsole(0,"Backup Integrity Check Task Completed")
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Set tLogStatus = ..WriteToCConsole(2,"Unable to perform Backup Integrity Check Task: "_ tStatus)
	}
	ZN tOrigNS
	Quit tStatus
]]></Implementation>
</Method>

<Method name="WriteToCConsole">
<Description>
A wrapper around the writes to cconsole.log.  The wrapper uses the ..CConsoleLogLevel
setting to determine if the even should be logged or not.</Description>
<FormalSpec>pLogLevel:%Integer,pLogMessage:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If ((..CConsoleLogLevel'="")&&(..CConsoleLogLevel<=pLogLevel)){
		Set tStatus=##class(%SYS.System).WriteToConsoleLog(pLogMessage,0,pLogLevel)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CheckDBByListType">
<Description>
A wrapper around the integrity check that handles the result stream for each 
database list. </Description>
<FormalSpec><![CDATA[pDBList:%String,pHeaderCaption:%String,pDBArray:%ArrayOfDataTypes,&pResultStream:%Stream.TmpCharacter]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		#;Create temp stream to hold results if zero after check then no integ checks were performed
		Set tTempStream = ##class(%Stream.TmpCharacter).%New()
		#;Write Database list type header to final email stream
		Do pResultStream.WriteLine("------------"_pHeaderCaption_ " Integrity Check-----------")
		#;Perform Integ check for all db's found in TrackCare list
		Set tStatus = ..CheckDBListIntegrity(pDBList,pDBArray,.tTempStream)
		#;If the stream is zero then no db's where checked -- either the list was null
		#; or none of the databases in the list could be mounted.
		If (tTempStream.SizeGet()=0){
			Do pResultStream.WriteLine("No "_pHeaderCaption_" Mounted or Evaluated")
		}Else{
			#;Copy Integ check summary from temp stream to final email stream
			Do pResultStream.CopyFrom(tTempStream)
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CheckDBListIntegrity">
<Description>
The core method that will attempt to mount each database found in pDBList and then
run the integrity check if the database is mountable.  All the integrity logs generated
for each database checked will be consolidated into a single log.
The summary results will be captured and returned in pResultStream.</Description>
<FormalSpec><![CDATA[pDBList:%ListOfDataTypes="",pDBArray:%ArrayOfDataTypes,&pResultStream:%Stream.TmpCharacter]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tOrigIO = $IO	
	Try{
		#; Get a list of db's as defined in the cache.cpf
		Set tTempIntegDir = ..LogDirectory
		Set tLogFileName = ..LogDirectory_..#LogFileName
		Set tCompletedCount = 0
		Set pResultStream = ##class(%Stream.TmpCharacter).%New()
		For i=1:1:$L(pDBList,","){
			Set tDBName = $P(pDBList,",",i)
			If (tDBName'=""){
				#;Set name for temporary file to hold integrity report for one database
				Set tTempIntegFileName = tTempIntegDir_"TempIntegReport.txt"
				#;Remove old temp integrity checks
				If (##class(%File).Exists(tTempIntegFileName)) Do ##class(%File).Delete(tTempIntegFileName)
				Set tDBDirectory = pDBArray.GetAt(tDBName)
				Do pResultStream.WriteLine(tDBName_":"_tDBDirectory)
			
				#;register an error when the db name is not found
				If (tDBDirectory="") {
					Set tMissingDBDirMessage = "Integrity Check Status: Database directory not found for: "_tDBName
					Do pResultStream.WriteLine(tMissingDBDirMessage)
					Set tLogStatus = ..WriteToCConsole(0,tMissingDBDirMessage)
				}Else{
					#;Mount Database
					Set tStatus = ..MountDB(tDBDirectory)
					If $$$ISERR(tStatus){
						#;write error to report stream
						Do pResultStream.WriteLine("Integrity Check Status: "_tStatus)
					}Else{
						#;Check Integrity
						#;Cannot use this as it is just a query for directories and status
						#;so the inegrity log gets over-written with each new directory
						#;Set tResult = ##class(%ResultSet).%New("SYS.Database:Integrity")
						#;Set tIntegrityStatus = tResult.Execute(tDBName_"*",tTempIntegFileName)
						#;Can not use this as it jobs the Integrity check off and processing keeps
						#;going so there is no way to get the logs to attach and email.
						#;Set tIntegrityStatus = ##class(SYS.Database).SilentIntegrityCheck(tTempIntegFileName,$lb(tDBDirectory))
						#;Open the file and change $IO to the file to log the output to the file
						Open tTempIntegFileName:("NRW"):5 If '$test $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to open "_tTempIntegFileName))
						Use tTempIntegFileName
						#;Call integrity check that logs to current device which is now the file
						Set tCheckStart = $ZDateTime($H,2)
						Set tIntegrityStatus = ##class(SYS.Database).IntegrityCheck($lb(tDBDirectory))
						Set tCheckStop = $ZDateTime($H,2)
						#;Close the file
						Close tTempIntegFileName
						#;Return to the original default device
						Use tOrigIO
						#;Set tCheckStatus = tStatus //tResult.Data("Status")
						#;Set tStatus = tResult.Close()
						#;Write out summary to Return stream
						Do pResultStream.WriteLine("Integrity Check Status:"_tIntegrityStatus)
						Do pResultStream.WriteLine("Approximate Start Time:"_tCheckStart)
						Do pResultStream.WriteLine("Approximate End Time:"_tCheckStop)
						#;Copy temp integ log to configured log
						Do pResultStream.WriteLine(..CopyFile(tTempIntegFileName,tLogFileName))
						#;Remove temp integ log
						Do ##class(%File).Delete(tTempIntegFileName)
						Set tCompletedCount = tCompletedCount + 1
						Set tLogStatus = ..WriteToCConsole(0,"Integrity Check for "_tDBName_":"_tDBDirectory_" successfully completed")
					}
				}
				Do pResultStream.WriteLine() //Line spacer between configured database
			}
		}
		Set:(tCompletedCount<=0) pResultStream = ##class(%Stream.TmpCharacter).%New() 
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Set tLogStatus = ..WriteToCConsole(1,"Integrity check failed during the following database checks  "_pDBList_": "_ tStatus)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="MountDB">
<Description>
Mounts the database found in pDBDirectory
Any error but 19 (database already mounted) will be thrown and returned
as the status.</Description>
<FormalSpec>pDBDirectory:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	
	Try{
		If (pDBDirectory'="") {
			#; Mount DB
			Set tStatus = ##class(SYS.Database).MountDatabase(pDBDirectory,0,0)
			If '$$$ISOK(tStatus) {
				#;If not OK check if it is Error 19 (Database already mounted
				Set tDecomposedStatus = $system.Status.DecomposeStatus(tStatus,.tErrorlist)
				Set tErrId = $o(tErrorlist(""),-1)
				Set tErrorDesc = $g(tErrorlist($g(tErrId)))
	            Set tErrorCode = $g(tErrorlist($g(tErrId),"code"))
	            #;If not 19 throw the error
	            If (tErrorCode'=19){ //if 19 already mounted otherwise throw error
		            $$$ThrowStatus($$$ERROR(tErrorCode,$system.Status.GetErrorText(tStatus)))
	            }Else{
		            #; If 19 set to OK as the integrity check can be performed.
					Set tStatus = $$$OK
	            }
			}
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Set tLogStatus = ..WriteToCConsole(1,"Failed to mount  "_pDBDirectory_": "_ tStatus)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CopyFile">
<Description>
Copies the contents from pSource to pTarget.  If pTarget does not exist or 
pAppend is set to 0 pTarget is created.  If pTarget exists and pAppend is set to 0
the existing pTarget is overwritten.
Used for copying Integrity logs from individual logs to consolidated logs.
If the word "Elapsed" if found at the beginning of a line in the pSource file that line
of text is returned from the method.</Description>
<FormalSpec>pSource:%String,pTarget:%String,pAppend:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tElapsedTime = ""
	Try{
		Set tSourceFile = ##class(%File).%New(pSource)
		Set tStatus = tSourceFile.Open("RWS")
		Set tTargetFile = ##class(%File).%New(pTarget)
		If (('##class(%File).Exists(pTarget))||(pAppend=0)) {
			#;Open and create if does not exist or not intended to append
			Set tStatus = tTargetFile.Open("RWSN")
		}Else{
			#;Open an existing file.
			Set tStatus = tTargetFile.Open("RWS")
		}
		While 'tTargetFile.AtEnd{
			Do tTargetFile.Read() //Advance to the end of the file
		}
		Do tSourceFile.Rewind() //Rewind the source to the beginning
		Set tEBreak = 0
		#;Doing a loop as the CopyFrom and CopyFile methods do not seem to work
		While 'tSourceFile.AtEnd{
			Set tCurrentLine = tSourceFile.ReadLine()
			Do tTargetFile.WriteLine(tCurrentLine)
			If ($E(tCurrentLine,1,7)="Elapsed"){
				Set tElapsedTime = tCurrentLine
			}
		}
		Do tTargetFile.%Save()
		Do tTargetFile.Close()
		Do tSourceFile.Close()
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Set tLogStatus = ..WriteToCConsole(1,"Failed to copy "_pSource_" to "_pTarget_": "_ tStatus)
	}
	Quit tElapsedTime
]]></Implementation>
</Method>

<Method name="GetArrayOfDBs">
<Description>
Creates and populates an array that contains the directories of databases
configured in the cache.cpf file with the database name as the key of the array.</Description>
<FormalSpec><![CDATA[&pDBArray:%ArrayOfDataTypes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set pDBArray = ##class(%ArrayOfDataTypes).%New()
	Try{
		set tResult = ##class(%ResultSet).%New("Config.Databases:List")
		set tStatus = tResult.Execute("*")
		While (tResult.Next(.tStatus)){
			Do pDBArray.SetAt(tResult.Data("Directory"),tResult.Data("Name"))
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Set tLogStatus = ..WriteToCConsole(1,"Unable to get an array of databases using Config.Databases:List: "_ tStatus)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="RunIntegrityCheck">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	#;Name of the Backup Integrity Check class
	#; --only need to change if the class name changes
	Set tTaskClass = "zCustom.TC.Task.BackupIntegrityCheck"
	Set (tTaskId,tTaskNamespace)=""
	Set tOrigNS = $ZU(5) 
	Try{
		#;Find the task by task class -- assume only one configured per instance
		#;Since one task can be configured to check all the databases.
		&sql(Select Id, Namespace 
				Into :tTaskId, :tTaskNamespace 
				From %SYS.Task 
				Where TaskClass = :tTaskClass)
		If (SQLCODE=0){
			If (tTaskId'=""){
				If (tTaskNamespace'=""){ //It will never be null if we get here
					#;Get the system/generic task definition
					Set tSysTask = ##class(%SYS.Task).%OpenId(tTaskId)
					#;Create new specific task
					Set tTask = $ClassMethod(..%ClassName(1),"%New")
					#;Set all the settings for the specific task
					For i=1:2:$LL(tSysTask.Settings){
						Set tSetting = $LG(tSysTask.Settings,i)
						Set tValue = $LG(tSysTask.Settings,i+1)
						Set $Property(tTask,tSetting)=tValue
					}
					#;Change to the namespace hosting the task/task code and run task
					ZN tTaskNamespace 
					Set tStatus = tTask.OnTask()
					ZN tOrigNS
				}
			}		
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="Test">
<Description>
Test method that instantiates a task, configures it, and runs OnTask
To use modify the settings in the method for your specific environment
and run from the terminal prompt: w ##class(zCustom.TC.Task.BackupIntegrityCheck).Test()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tTask = ##class(zCustom.TC.Task.BackupIntegrityCheck).%New()	
	Set tTask.TrakCareDBList ="RUSHFTP,SAMPLES"
	Set tTask.TrakCareLabDBList ="UCH"
	Set tTask.TrakCareIntegDBList ="USER"
	Set tTask.OtherDBList =""
	Set tTask.AttachIntegrityLogs =0
	Set tTask.CConsoleLogLevel=1
	Set tTask.AttachIntegrityLogs=1
	Set tTask.LogDirectory ="C:\tmp\scotland"
	Set tTask.EmailSubject="Test integrity check"
	Set tTask.EMPCredentials="J2Email"
	Set tTask.FromEmailAddress="mlortz@j2-interactive.com"
	Set tTask.ToEmailAddresses="mlortz@j2-interactive.com"
	Set tTask.SMTPPort="587"
	Set tTask.SMTPServer="smtp.gmail.com"
	Set tTask.SSLConfig="Mail"
	Quit tTask.OnTask()
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.ECPClientMonitor">
<Description>
Monitors the ECP connection to the data server.
If the connection is in an error state an email is sent 
and the web server can be shut down shut down.
Error states includes: Failed, Not Connected, Disabled, Init, In progress and Troubled
If the connection is in Init, In progress, or troubled the task will wait
for SecondCheckWaitTime seconds and then check the status again and if the connection
is still in the same state it will be considered an error.</Description>
<IncludeCode>%occOptions,%occStatus</IncludeCode>
<Super>zCustom.TC.Task.GenericEmail</Super>
<TimeChanged>63336,39275.44388</TimeChanged>
<TimeCreated>63336,38384.252578</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/ECPClientMonitor.xml#1 $</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;</Description>
<Type>STRING</Type>
<Default>ECP Client Status Check</Default>
</Parameter>

<Property name="SecondCheckWaitTime">
<Description>
If a connection is in the init, in progress, or troubled state
The task waits for the configured amount of time before checking the status
a second time.  
The units for this configuration item is seconds and the default is 60 seconds.
If value is not set or a negative number it will default to 0.</Description>
<Type>%Integer</Type>
<InitialExpression>60</InitialExpression>
</Property>

<Property name="StopWebServer">
<Description>
If true and an error is found with any ECP connection
an attempt will be made to shut down the web server found on the server
by executing the OS command found in WebServerShutdownCommand</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="WebServerShutdownCommand">
<Description>
The appropriate OS command to shut down the web server.</Description>
<Type>%String</Type>
<InitialExpression>"service httpd stop"</InitialExpression>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="SendEmailOnError">
<Description>
If true an email will be sent containing information regarding all ECP connections
if any ECP connection has a status of anything but 'normal' or 'recovering'</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Parameter name="BigNetCStatusInit">
<Description>
The following parameters are System values for the various
possible ECP states.
System ECP Status</Description>
<Type>%Integer</Type>
<Default>0</Default>
</Parameter>

<Parameter name="BigNetCStatusNotConnected">
<Description>
System ECP Status</Description>
<Type>%Integer</Type>
<Default>1</Default>
</Parameter>

<Parameter name="BigNetCStatusConnectInProgress">
<Description>
System ECP Status</Description>
<Type>%Integer</Type>
<Default>2</Default>
</Parameter>

<Parameter name="BigNetCStatusConnectFailed">
<Description>
System ECP Status</Description>
<Type>%Integer</Type>
<Default>3</Default>
</Parameter>

<Parameter name="BigNetCStatusDisabled">
<Description>
System ECP Status</Description>
<Type>%Integer</Type>
<Default>4</Default>
</Parameter>

<Parameter name="BigNetCStatusNormal">
<Description>
System ECP Status</Description>
<Type>%Integer</Type>
<Default>5</Default>
</Parameter>

<Parameter name="BigNetCStatusTrouble">
<Description>
System ECP Status</Description>
<Type>%Integer</Type>
<Default>6</Default>
</Parameter>

<Parameter name="BigNetCStatusRecovery">
<Description>
System ECP Status</Description>
<Type>%Integer</Type>
<Default>7</Default>
</Parameter>

<Parameter name="ConnStatus">
<Description>
The following parameters are used as keys for an array
that is used to temporarily hold the connection status and details.
Connection Status array Key used when collecting ECP details</Description>
<Type>%Integer</Type>
<Default>1</Default>
</Parameter>

<Parameter name="ConnName">
<Description>
Connection Name array Key used when collecting ECP details</Description>
<Type>%Integer</Type>
<Default>2</Default>
</Parameter>

<Parameter name="SourceIP">
<Description>
Source IP Address array Key used when collecting ECP details</Description>
<Type>%Integer</Type>
<Default>3</Default>
</Parameter>

<Parameter name="SourcePort">
<Description>
Source Port array Key used when collecting ECP details</Description>
<Type>%Integer</Type>
<Default>4</Default>
</Parameter>

<Parameter name="DestIP">
<Description>
Destination IP Address array Key used when collecting ECP details</Description>
<Type>%Integer</Type>
<Default>5</Default>
</Parameter>

<Parameter name="DestPort">
<Description>
Destination Port Address array Key used when collecting ECP details</Description>
<Type>%Integer</Type>
<Default>6</Default>
</Parameter>

<Parameter name="EmailMessage">
<Description>
Key for the connection status message that is use for the email message</Description>
<Type>%Integer</Type>
<Default>7</Default>
</Parameter>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/* 
 	ALGORITHM:
 	Loop through array of data server slots. This value determined by
 	"Maximum number of data servers" in "This System as an ECP Application
 	Server" section of System Management Portal. 
 	([Home]>[Configuration]>[ECP Settings])
 	
 	For each server slot, run $system.ECP.GetClientState(serverslot)
 	
 	If the return value is:
 	
 	  -1: This slot is beyond the array bounds (doesn't exist). Stop the loop.
 	   1: This slot is available, but not allocated. Skip.
 	   ^-delimited val: $piece() the return code and determine status.
 	
	 */
	Set tStatus = $$$OK
	Set tECPDown = 0
	Set tWebServerStopped = 0
	Set tStatusMessage = ""
	Set tECPStatusList = ""
	Set tOrigNS = $ZU(5)
	Try{
		Set tStatus = ..CollectECPStats(.tECPStatusList)
		For i=1:1:tECPStatusList.Count() {
			Set tConnArray = tECPStatusList.GetAt(i)
			Set tConnStatus = tConnArray.GetAt(..#ConnStatus)
			// Status Handling:
			/*
			  	If BigNetCStatusConnectFailed,BigNetCStatusNotConnected or BigNetCStatusDisabled, 
			  		then set fail flag automatically
			  	If BigNetCStatusInit, BigNetCStatusConnectInProgress, or BigNetCStatusTrouble,
			  		then wait some amount of time, check for same status, and set fail flag accordingly
			  	If BigNetCStatusNormal or BigNetCStatusRecovery, do not set the fail flag. 
			  
			  */
			  
			If ((tConnStatus=..#BigNetCStatusConnectFailed) || (tConnStatus=..#BigNetCStatusNotConnected) || (tConnStatus=..#BigNetCStatusDisabled)) {
				Set tECPDown=1  
				Set tStatusMessage = "Connection in '"
				Set tStatusMessage = tStatusMessage _$S(tConnStatus=..#BigNetCStatusConnectFailed:"Failed",tConnStatus=..#BigNetCStatusNotConnected:"Not Connected",tConnStatus=..#BigNetCStatusDisabled:"Disabled")
				Set tStatusMessage = tStatusMessage _"' state."
								

			} ElseIf ((tConnStatus=..#BigNetCStatusInit) || (tConnStatus=..#BigNetCStatusConnectInProgress)) {
				#;Init timeout in ECP code is 20 seconds for client
				#;I'm guessing that the ConnectInProgress either fails
				#;if the data server rejects it or a TCP timeout occurs.
				#;Either way, 1 minute or more to connect is worth an alert.
				Hang ..SecondCheckWaitTime 
				#; Refresh ECP stats
				Set tConnStatus = ..GetECPConnStatus(i-1)
				Do tConnArray.SetAt(tConnStatus,..#ConnStatus)				
				If (tConnStatus=..#BigNetCStatusInit || tConnStatus=..#BigNetCStatusConnectInProgress){
					Set tStatusMessage = "Connection in '"
					Set tStatusMessage = tStatusMessage _ $S(tConnStatus=..#BigNetCStatusInit:"Init",tConnStatus=..#BigNetCStatusConnectInProgress:"In Progress")
					Set tStatusMessage = tStatusMessage _"' state longer than normal."
					Set tECPDown=1  
				}
			} ElseIf(tConnStatus=..#BigNetCStatusTrouble) {			
				Hang ..SecondCheckWaitTime //Wait and re-try
				#; Refresh ECP stats
				W "This is it " _ i,!
				Set tConnStatus = ..GetECPConnStatus(i-1)
				Do tConnArray.SetAt(tConnStatus,..#ConnStatus)
				If (tConnStatus=..#BigNetCStatusTrouble){
					Set tStatusMessage = "Connection in 'troubled' state."
					Set tECPDown=1  
				}
			}ElseIf ((tConnStatus = ..#BigNetCStatusNormal)||(tConnStatus = ..#BigNetCStatusRecovery)){
				Set tStatusMessage = "Connection in '"_$S(tConnStatus=..#BigNetCStatusNormal:"Normal",tConnStatus=..#BigNetCStatusRecovery:"Recovery")_"' state."
			}
			If ((tECPDown=1)&&(..StopWebServer=1)&&(..WebServerShutdownCommand'="")){
				#; Toggle flag so web server is only stopped the one type
				#; TODO: Check web server status directly v. using a flag.
				Set tWebServerStopped = 1
				Set tStatus = ##class(zCustom.TC.Task.Util.OSCommand).ExecutePipe(..WebServerShutdownCommand,.tOSOutput)
				#;TODO: Check status
			}
			Do tConnArray.SetAt(tStatusMessage,..#EmailMessage)
			Do tECPStatusList.SetAt(tConnArray,i)

		}
		#;Not sending error email until all the connections are checked so only one
		#;email is sent per task run but all connection status info is sent.
		#;Only build and send a message if send on error is selected and in error state
		If ((tECPDown=1)&&(..SendEmailOnError=1)){
			Set tMessage = ..PrepareEmailMassage(tECPStatusList, tOSOutput)
			Set tStatus = ..SendEmail(tMessage)
		}
 	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetECPConnStatus">
<FormalSpec>pConnectionNumber:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	W "Start",!
	Set tOrigNS = $ZU(5)
	Set tStatus = $$$OK
	Set tConnStatus = ""
	Try{
		ZN "%SYS"
		Set tConnStatus = $P($system.ECP.GetClientState(pConnectionNumber),"^",1)
		ZN tOrigNS
	W "End "_ tConnStatus_":"_pConnectionNumber,!
	}Catch(ex){
		ZN tOrigNS
		Set tStatus = ex.AsStatus()
	}
	Quit tConnStatus
]]></Implementation>
</Method>

<Method name="PrepareEmailMassage">
<FormalSpec>pConnections:%ArrayOfDataTypes,pWebServerOutput:%ListOfDataTypes=""</FormalSpec>
<ReturnType>%Stream.TmpCharacter</ReturnType>
<Implementation><![CDATA[
	Set tMessage = ##class(%Stream.TmpCharacter).%New()
	Do tMessage.WriteLine("ECP Connection Status")
	Set tHasError = 0
	For i=1:1:pConnections.Count(){
		Set tConn = pConnections.GetAt(i)
		Set tConnStatus= tConn.GetAt(..#ConnStatus)
		#;Check to see if it is one of the bad status states
		If ((tHasError=0)&&((tConnStatus'=..#BigNetCStatusNormal)||(tConnStatus'=..#BigNetCStatusRecovery))){
			Set tHasError = 1
		}
		Do tMessage.WriteLine("Connection: " _ i)
		Do tMessage.WriteLine("Name: " _ tConn.GetAt(..#ConnName))
		Do tMessage.WriteLine("Status Message: " _ tConn.GetAt(..#EmailMessage))
		Do tMessage.WriteLine("Current Status Code: " _ tConnStatus)
		Set tConnDesc = "ECP Connection from " 
		Set tConnDesc = tConnDesc_ tConn.GetAt(..#SourceIP) _":"_tConn.GetAt(..#SourcePort)
		Set tConnDesc = tConnDesc_ " to "_ tConn.GetAt(..#DestIP)_":"_ tConn.GetAt(..#DestPort)_"."
		Do tMessage.WriteLine(tConnDesc)
	}

	#;Clear the message if there is no error.
	If (tHasError=0){
		Set tStatus = tMessage.Clear()
	}Else{
		If (pWebServerOutput'=""){
			Do tMessage.WriteLine()
			Do tMessage.WriteLine("Results of web server shutdown")
			For j=1:1:pWebServerOutput.Count(){
				Do tMessage.WriteLine(pWebServerOutput.GetAt(j))
			}
		}
	}
	d tMessage.Rewind()
	w tMessage.Read()
	d tMessage.Rewind()
	Quit tMessage
]]></Implementation>
</Method>

<Method name="CollectECPStats">
<FormalSpec><![CDATA[&pStats:%ListOfDataTypes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
 	Set tOrigNS = $ZU(5)
	Set pStats = ##class(%ListOfDataTypes).%New()
	Try{
		Set tConnNum=0
	 	ZN "%SYS"
	 	Set tStatus=$system.ECP.GetClientState(tConnNum)
	 	While(tStatus'=-1) {
		 	Set tConnArray = ##class(%ArrayOfDataTypes).%New()
		 	Do tConnArray.SetAt($P(tStatus,"^",1),..#ConnStatus)
		 	Do tConnArray.SetAt($P(tStatus,"^",3),..#ConnName)
		 	Do tConnArray.SetAt($P(tStatus,"^",4),..#SourceIP)
		 	Do tConnArray.SetAt($P(tStatus,"^",5),..#SourcePort)
		 	Do tConnArray.SetAt($P(tStatus,"^",6),..#DestIP)
		 	Do tConnArray.SetAt($P(tStatus,"^",7),..#DestPort)
		 	Do tConnArray.SetAt("",..#EmailMessage)
			Do pStats.Insert(tConnArray)
			Set tConnNum=tConnNum+1 	 
			Set tStatus=$system.ECP.GetClientState(tConnNum)
		 }	
		 ZN tOrigNS
	}Catch (ex){
		ZN tOrigNS
		Set tStatus = ex.AsStatus()	
	}
	Quit:(tStatus=-1) $$$OK
]]></Implementation>
</Method>

<Method name="SecondCheckWaitTimeGet">
<Description>
Ensure value is greater than or equal to zero.</Description>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tSecondCheckWaitTime = i%SecondCheckWaitTime
	Set:tSecondCheckWaitTime<0 tSecondCheckWaitTime = 0
	Quit tSecondCheckWaitTime
]]></Implementation>
</Method>

<Method name="TestTask">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	 Set tTask = ##class(zCustom.TC.Task.ECPClientMonitor).%New()
	 Set tTask.EMPCredentials = "J2Email"
	 Set tTask.EmailSubject="Automated Shadowing Report"
	 Set tTask.FromEmailAddress = "mlortz@j2-interactive.com"
	 Set tTask.ToEmailAddresses ="mlortz@j2-interactive.com"
	 Set tTask.SMTPPort=587
	 Set tTask.SMTPServer = "smtp.gmail.com"
	 Set tTask.SSLConfig = "Mail"
	 Set tTask.SendEmailOnError = 1
	 Set tTask.StopWebServer = 1
	 Set tTask.SecondCheckWaitTime = 1
	 Set tTask.WebServerShutdownCommand="net stop ""Apache2"""
	 Set tStatus = tTask.CollectECPStats(.tECPStatusList)
	 d $system.OBJ.Dump(tECPStatusList.GetAt(1))
	 Set tStatus = tTask.OnTask()
	 Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.ECPServerMonitor">
<Description>
This task is fairly simple. It checks the connection state for each connection
and sends a warning for any that are in trouble. Following assumptions apply:

1) It is possible to set the number of allowed app servers greater than the number
really used. So the connection status of "FREE" is not considered an error.

2) It is assumed that a connection in recovery is not worth alerting. It might be decided later
that recovery should only last so long, but for now, it is not alerted.

The "Restart" connection state indicates that we are waiting for a 
connection to reconnect. Treat as "Free".</Description>
<Super>zCustom.TC.Task.GenericEmail</Super>
<TimeChanged>63336,38445.190081</TimeChanged>
<TimeCreated>63336,38445.190081</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/ECPServerMonitor.xml#1 $</Default>
</Parameter>

<Parameter name="Free">
<Description>
The following are ECP SErver States</Description>
<Type>%Integer</Type>
<Default>0</Default>
</Parameter>

<Parameter name="Normal">
<Type>%Integer</Type>
<Default>1</Default>
</Parameter>

<Parameter name="Trouble">
<Type>%Integer</Type>
<Default>2</Default>
</Parameter>

<Parameter name="Recovering">
<Type>%Integer</Type>
<Default>3</Default>
</Parameter>

<Parameter name="Restart">
<Type>%Integer</Type>
<Default>4</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;
This is defined in subclasses.</Description>
<Type>STRING</Type>
<Default>ECP Server Status Check</Default>
</Parameter>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tEmailStream = ##Class(%Stream.TmpCharacter).%New()
	Try{
		Set tSendMail=0
	 	Do tEmailStream.WriteLine("ECP Status Report (per application server):")
	 	Set tConnNum=1 //The array for server connections starts with 1 and NOT 0 !!!
	 	Set tECPState=$system.ECP.GetServerState(tConnNum)
	 	While(tECPState'=-1) {
			 //Make sure the connection is not free
			 If (tECPState'=..#Free) {
				 Set tECPStatusCode=$p(tECPState,"^",1)
				 Set tAppHostName=$p(tECPState,"^",3)
				 Set tAppIP=$p(tECPState,"^",5)
				 Set tAppPort=$p(tECPState,"^",6)
				 //Check for trouble state
				 If (tECPStatusCode=..#Trouble) {
					 //Logic for handling trouble state
					 Do tEmailStream.WriteLine("Connection slot "_tConnNum_"("_tAppHostName_" "_tAppIP _":"_tAppPort_"): TROUBLE")
					 Set tSendMail=1
				 } elseif (tECPStatusCode=..#Normal) {
					 Do tEmailStream.WriteLine("Connection slot "_tConnNum_"("_tAppHostName_" "_tAppIP _":"_tAppPort_"): Normal")
				 } elseif (tECPStatusCode=..#Recovering) {
					 Do tEmailStream.WriteLine("Connection slot "_tConnNum_"("_tAppHostName_" "_tAppIP _":"_tAppPort_"): Recovering")
				 } elseif (tECPStatusCode=..#Restart) {
					 Do tEmailStream.WriteLine("Connection slot "_tConnNum_"("_tAppHostName_" "_tAppIP _":"_tAppPort_"): Restarting")
				 }
			 } Else {
				 Do tEmailStream.WriteLine("Connection slot "_tConnNum_": Free (not utilized)")
			 }
			 Set tConnNum=tConnNum+1
			 Set tECPState=$system.ECP.GetServerState(tConnNum)
		 }
		 If (tSendMail) {
			 Set tStatus = ..SendEmail(tEmailStream)
		 }
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.GenericEmail">
<Description>
A generic base class for tasks that need to send emails.
This task in and of it self does nothing.  Subclasses are expected to 
implement specific task functionality and use the SendEmail() method.</Description>
<Super>%SYS.Task.Definition</Super>
<TimeChanged>63336,39303.504231</TimeChanged>
<TimeCreated>63336,37278.714647</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/GenericEmail.xml#1 $</Default>
</Parameter>

<Property name="SMTPServer">
<Description>
SMTP server if an email needs to be sent</Description>
<Type>%String</Type>
</Property>

<Property name="SMTPPort">
<Description>
SMTP Port if an email needs to be sent</Description>
<Type>%Integer</Type>
<InitialExpression>25</InitialExpression>
</Property>

<Property name="EMPCredentials">
<Description>
The name of the Ensemble Management Portal credentals that can
be used to access the SMTP server.  If this is set the value will
be used to authenticate with the SMTP server.  If this is not
set then the values in SMTPUser and SMTPPassword will be used
to authenticate to the SMTP server.</Description>
<Type>%String</Type>
</Property>

<Property name="SMTPUser">
<Description>
If the EMPCredentials is not set this is used as the username
to authenticate with the SMTP server.</Description>
<Type>%String</Type>
</Property>

<Property name="SMTPPassword">
<Description>
If the EMPCredentials is not set this is used as the password
to authenticate with the SMTP server.</Description>
<Type>%String</Type>
</Property>

<Property name="SSLConfig">
<Description>
If the SMTP Server requires an SSL connection set up the connection
in the System Management Home and use the configuration name from there
here.</Description>
<Type>%String</Type>
</Property>

<Property name="FromEmailAddress">
<Description>
The email address that any sent emails will come from.</Description>
<Type>%String</Type>
</Property>

<Property name="EmailSubject">
<Description>
The subject of emails.</Description>
<Type>%String</Type>
<InitialExpression>"Unimplemented"</InitialExpression>
</Property>

<Property name="ToEmailAddresses">
<Description>
A common seperated list of email addresses that should received emails generated
by this task.</Description>
<Type>%String</Type>
</Property>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;
This is defined in subclasses.</Description>
<Type>STRING</Type>
<Default>Unimplemented -- Email Task base</Default>
</Parameter>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Set tStatus = $$$OK
	Try{
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="SendEmail">
<FormalSpec>pMessage:%Stream.TmpCharacter,pAttachFileName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tEmailer = ##class(zCustom.TC.Task.Util.Email).%New()
	Set tEmailer.EMPCredentials = ..EMPCredentials
	Set tEmailer.EmailSubject = ..EmailSubject
	Set tEmailer.FromEmailAddress = ..FromEmailAddress
	Set tEmailer.SMTPUser = ..SMTPUser
	Set tEmailer.SMTPPassword = ..SMTPPassword
	Set tEmailer.SMTPPort = ..SMTPPort
	Set tEmailer.SMTPServer = ..SMTPServer
	Set tEmailer.SSLConfig = ..SSLConfig
	Set tEmailer.ToEmailAddresses = ..ToEmailAddresses
	Quit tEmailer.SendEmail(pMessage,pAttachFileName)
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.JournalBackup">
<Description>
Backup journal files on a regular basis.
In order for this to work the Alternate Journal Directory must be set.
The task will switch the journal copy all journal files found in the
journal dirctory not in the alternate journal directory to the alternate journal directory
and pruge journal files from the alternate journal directory that are older than
the retention value and write the results of the task run to the cconsole.log</Description>
<IncludeCode>EnsUtil,%syJrninc</IncludeCode>
<Super>%SYS.Task.Definition</Super>
<TimeChanged>63336,39316.957753</TimeChanged>
<TimeCreated>63336,38494.596845</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/JournalBackup.xml#1 $</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;
This is defined in subclasses.</Description>
<Type>STRING</Type>
<Default>Journal Backup</Default>
</Parameter>

<Property name="Retention">
<Description>
The number of hours to retain backed up journals in the alternate journal directory.</Description>
<Type>%Integer</Type>
</Property>

<Property name="Suffix">
<Description>
File suffix to be used when moving the journal files.  
This value is appended to the end of the journal file name to easily
indicate that the journal files were moved to the alternate journal directory
from the primary journal directory v. generated directly into the alternate
journal directory for what ever reason.
If a value is not set it is defaulted to ".journalbackup"
It is impossible not to have some sort of suffix.</Description>
<Type>%String</Type>
<InitialExpression>".journalbackup"</InitialExpression>
</Property>

<Property name="BackupDirectory">
<Description>
If populated the directory will be used for back up
If not populated defaults to the alternate journal directory.
If alternate and this is not set backup will fail.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Property name="SwitchJournal">
<Description>
Flag to switch the journals right before the back up.
This will usually be set to true otherwise it will more than
likely be a meaningless task if the frequency of the task if more
often than the usual jounral switch process.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="SuffixGet">
<Description>
Make sure there is always a suffix.  Defaults to .journalbackup</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSuffix = i%Suffix
	Set:tSuffix="" tSuffix = ".journalbackup"
	Quit tSuffix
]]></Implementation>
</Method>

<Method name="RetentionGet">
<Description>
Make sure there is always a retention period.  Defaults to 24 hours</Description>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tRetention = i%Retention
	Set:tRetention="" tRetention = 24
	Quit tRetention
]]></Implementation>
</Method>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tOrigNS = $ZU(5)
	Try{
		Set (tPrimaryFileList,tAltFileArray) =""
		
		#;Build an array of files found in the journal directory
		Set tJournalDir = ##class(%SYS.Journal.System).GetPrimaryDirectory()
		Set tStatus = ..GetDirFileArray(tJournalDir,.tPrimaryFileArray)
		If ((tStatus'=$$$OK)||(tJournalDir="")) $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Could not determine primary journal location."))
		
		If (..BackupDirectory=""){
			Set tAltJournalDir = ##class(%SYS.Journal.System).GetAlternateDirectory()
		}Else{
			Set tAltJournalDir = ##class(%File).NormalizeDirectory(..BackupDirectory)
		}
		#; check that the alt and primary directories are not the same otherwise makes no sense to copy.
		#; convert to lower cause if alt dir not set defaults to pri dir but seems to be all lower case.
		If ($ZCVT(tAltJournalDir,"l")=$ZCVT(tJournalDir,"l")) $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Primary and alternate journal directories are the same."))
		#;Make sure the target backup directory exists
		If ('##class(%File).DirectoryExists(tAltJournalDir)){
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Target backup directory does not exist."))
		}
		#;Build an array of files found in the alternate journal directory
		Set tStatus = ..GetDirFileArray(tAltJournalDir,.tAltFileArray)
		If ((tStatus'=$$$OK)||(tAltJournalDir)) $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Could not determine alternate journal location."))
		If (..SwitchJournal=1){
			#;Check the state of journal and perform a journal switch if everything is normal
			Set tState = ##class(%SYS.Journal.System).GetStateString()
			If (tState="Normal"){
				ZN "%SYS"
				#;Using the 'by backup' reason for the journal switch
				Set tStatus = ##class(%SYS.Journal.System).SwitchFile(tJournalDir,tAltJournalDir,,,,$$$JRNSWREASONBACKUP)
				ZN tOrigNS
			}Else{
				#;Throw an error if state is not normal
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Journal state ("_tState_") is not 'Normal'."))
			}
			#;Thow an error if the switch failed.
			If (tStatus'=$$$OK) $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Unsuccessful journal switch attempt."))
		}
		Set tCurrentJournal = ##class(%SYS.Journal.System).GetCurrentFileName()
		#;Back up the journal files
		Set tStatus = ..GetCopyList(tPrimaryFileArray,tAltFileArray,tCurrentJournal,.tCopyList)
		Set tStatus = ..CopyJournals(tJournalDir,tAltJournalDir,tCopyList)
		#;Purge old journal files
		Set tStatus = ..GetPurgeList(tAltFileArray,.tPurgeList)
		Set tStatus = ..PurgeFiles(tAltJournalDir,tPurgeList)
		Do ##class(%SYS.System).WriteToConsoleLog("Journal file backup succeeded.",,0) //Informational
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		ZN tOrigNS
		Do ##class(%SYS.System).WriteToConsoleLog("Journal file backup failed: "_$$$StatusDisplayString(tStatus),,1) //Warning
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PurgeFiles">
<Description>
All file names found in the pPurgeList are deleted from the pAltDirectory.
Successful deletes are logged to the cconsole.log as informational and failures as warnings.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pAltDirectory:%String,pPurgeList:%ListOfDataTypes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		For i=1:1:pPurgeList.Count(){
			Set tFileName = pPurgeList.GetAt(i)
			Set tCurrentJournal = ##class(%File).GetFilename(##class(%SYS.Journal.System).GetCurrentFileName())
			#;Again make sure it isn't the current journal file even though there are 
			#;two other checks in place and the journal has just been switched.
			Set:(tCurrentJournal'=tFileName) tStatus = ##class(%File).Delete(pAltDirectory_tFileName)
			If (tStatus=$$$OK){
				Do ##class(%SYS.System).WriteToConsoleLog("Purged back up journal file" _pAltDirectory_tFileName,,0) //Informational
			}Else{
				Do ##class(%SYS.System).WriteToConsoleLog("Failed to purged backed up journal file " _pAltDirectory_tFileName_" : "_$$$StatusDisplayString(tStatus),,1) //Warning
			}
		}
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetPurgeList">
<Description>
Determines the list of backed up journal files that are older than the configured ..Retention
period.  In addition to checking the age of the file the file must contain the configured
..Suffix value in order to be added to the purge list.</Description>
<FormalSpec><![CDATA[pAltArray:%ArrayOfDataTypes,&pPurgeList:%ListOfDataTypes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		Set tFileName = ""
		Set pPurgeList = ##class(%ListOfDataTypes).%New()
		Set tModifyDate = pAltArray.GetNext(.tFileName)
		While (tFileName'="") {
			#;Add file to purge list if too old and contains the backup suffix
			#; and is not the current journal file.
			Set tCurrentJournal = ##class(%File).GetFilename(##class(%SYS.Journal.System).GetCurrentFileName())
			If ((..IsFileTooOld(tModifyDate))&&(tFileName[..Suffix)&&(tCurrentJournal)){
				Do pPurgeList.Insert(tFileName)
			}
			Set tModifyDate = pAltArray.GetNext(.tFileName)
		}
	}Catch(ex){Set tStatus = ex.AsStatus()}	
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CopyJournals">
<Description>
All files found in pCopyList are copies from pPrimaryDirectory to pAltDirectory with
the configured suffix appended to the end of the file name.
The status of the copy attempt is logged to cconsole.log.
Successful copies are logged as information and failed attempts are logged
as warnings.</Description>
<FormalSpec>pPrimaryDirectory:%String,pAltDirectory:%String,pCopyList:%ListOfDataTypes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		For i=1:1:pCopyList.Count() {
			Set tFileName = pCopyList.GetAt(i)
			Set tStatus = ##class(%File).CopyFile(pPrimaryDirectory_tFileName,pAltDirectory_tFileName_..Suffix)
			If (tStatus=$$$OK){
				Do ##class(%SYS.System).WriteToConsoleLog(pPrimaryDirectory_tFileName_ " backed up to " _pAltDirectory_tFileName_..Suffix,,0) //Informational
			}Else{
				Do ##class(%SYS.System).WriteToConsoleLog("Failed to back up journal file " _pPrimaryDirectory_tFileName_ " to " _pAltDirectory_tFileName_..Suffix _" : "_$$$StatusDisplayString(tStatus),,1) //Warning
			}
		}
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetCopyList">
<Description>
Loops over pPrimaryArray of file names and looks for a match in the pAltArray of file names.
If the file is not in pAltArray the last modified date is checked to ensure it is not older
than the retention policy as it would just get deleted after being copied.
Also the current active journal file will not be added to the list.</Description>
<FormalSpec><![CDATA[pPrimaryArray:%ArrayOfDataTypes,pAltArray:%ArrayOfDataTypes,pCurrentJournal:%String,&pFileList:%ListOfDataTypes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		Set tFileName = ""
		Set pFileList = ##class(%ListOfDataTypes).%New() 
		Set tModifyDate = pPrimaryArray.GetNext(.tFileName)
		While (tFileName'="") {
			Set tAltModifyDate = pAltArray.GetAt(tFileName_..Suffix)
			#;W ":"_tFileName _ " alt date " _ tAltModifyDate _ " primary Date " _ tModifyDate_":"_..IsFileTooOld(tModifyDate),!
			If (tAltModifyDate=""){
				If ('(..IsFileTooOld(tModifyDate))){
					Do:(tFileName'=##class(%File).GetFilename(pCurrentJournal)) pFileList.Insert(tFileName)
				}
			}
			Set tModifyDate = pPrimaryArray.GetNext(.tFileName)
		}
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="IsFileTooOld">
<Description>
Returns boolean if pPastDate is older than (current date - ..Retention)
The expected format of pPastDate is ODBC (e.g. "2011-10-27 06:00:00")</Description>
<FormalSpec>pPastDate:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tSecondsDiff=0
	Try{
		Set tModifyDTH = $ZDTH(pPastDate,3)
		#; Multiply the number or retention hours by 60 minutes/hr by 60seconds/minute
		Set tRetentionSeconds = ..Retention*60*60
		Set tModifyDay = $P(tModifyDTH,",",1)
		Set tModifyHour = $P(tModifyDTH,",",2)
		Set tDayDiff = ((+$H)-tModifyDay)
		Set tSecondsDiff = (((tDayDiff*24)*(60*60))+($P($H,",",2)-tModifyHour))
	}Catch(ex){Set tStatus = ex.AsStatus()}
	#;W tRetentionSeconds _"<"_ tSecondsDiff _"="_(tRetentionSeconds < tSecondsDiff),!
	Quit (tRetentionSeconds < tSecondsDiff)
]]></Implementation>
</Method>

<Method name="GetDirFileArray">
<Description>
Builds an array with the file name as the key and the last modified date
for the file as the value for all the files in pDirectory
Directories are excluded from the list along with the lck file.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDirectory:%String,&pFileArray:%ArrayOfDataTypes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		Set pFileArray = ##class(%ArrayOfDataTypes).%New()
		Set tFileResults=##class(%ResultSet).%New("%Library.File:FileSet")
		Set tStatus=tFileResults.Execute(pDirectory)
		While (tFileResults.Next()) {
			Set tFileName = tFileResults.Data("Name")
			#;Only add files not directories
			If (('##class(%File).DirectoryExists(tFileName))&&('(tFileName[".lck"))){
				Do pFileArray.SetAt(tFileResults.Data("DateModified"),##class(%File).GetFilename(tFileName))
			}
		}
		Do tFileResults.Close()
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="TestTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRetention:%Integer,pSuffix:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tTask = ##class(zCustom.TC.Task.JournalBackup).%New()
	Set tTask.Retention = pRetention
	Set tTask.Suffix = pSuffix
		#;Build an array of files found in the journal directory
		Set tJournalDir = ##class(%SYS.Journal.System).GetPrimaryDirectory()
		W "Primary Journaling directory: " _ tJournalDir,!
		Set tStatus = tTask.GetDirFileArray(tJournalDir,.tPrimaryFileArray)
		If ((tStatus'=$$$OK)||(tJournalDir="")) $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Could not determine primary journal location."))
		#;Build an array of files found in the alternate journal directory
		Set tAltJournalDir = ##class(%SYS.Journal.System).GetAlternateDirectory()
		W "Alternate Journaling directory: " _ tAltJournalDir,!
		If (tAltJournalDir=tJournalDir) $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Primary and alternate journal directories are the same."))
		Set tStatus = tTask.GetDirFileArray(tAltJournalDir,.tAltFileArray)
		If ((tStatus'=$$$OK)||(tAltJournalDir)) $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting Journal Backup: Could not determine alternate journal location."))
		/*
		Set tFile = ""
		Set tDate = tAltFileArray.GetNext(.tFile)
		While (tFile'=""){
			W tDate _" -- " 
			W tFile_ ": This date " _ tDate _ " for the To Old Test " _ tTask.IsFileTooOld(tDate)
			Set tDate = tAltFileArray.GetNext(.tFile)
		}
		*/
		Set tCurrentJournal = ##class(%SYS.Journal.System).GetCurrentFileName()
		Set tStatus = tTask.GetCopyList(tPrimaryFileArray,tAltFileArray,tCurrentJournal,.tCopyList)
		For i=1:1:tCopyList.Count() {
			w tCopyList.GetAt(i),!
		}
		#;Check the state of journal and perform a journal switch if everything is normal
		Set tState = ##class(%SYS.Journal.System).GetStateString()
		W "Journaling State: " _ tState,!
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.OSCommand">
<Description>
A task used to execute OS Commands via the SMP Task Scheduler.</Description>
<IncludeCode>%sySite</IncludeCode>
<Super>%SYS.Task.Definition</Super>
<TimeChanged>63336,39330.032535</TimeChanged>
<TimeCreated>63336,38609.574514</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/OSCommand.xml#1 $</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;</Description>
<Type>STRING</Type>
<Default>OS Command</Default>
</Parameter>

<Property name="WriteToCConsole">
<Description>
If true the results of the OS command are written to the cconsole.log file
With the assumption that nagios or some other monitoring tool will be
used to alert when error occur.
If this is checked and the OS return value is not found in CConsoleWarnCodes
or CConsoleWarnCodes then the output from the OS command will be written to the
cconsole.log as informational only.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="OSCommand">
<Description>
The operating system command exactly as you would like the command to be run.
All stderr information is automatically re-directed to stdout and captured
when the os command is executed.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="CConsoleWarnCodes">
<Description>
A comma separated list of codes that can be returned from the OS command
If the OS command returns a value found in CConsoleWarnCodes then all
output from the OS command will be logged to the cconsole.log as a warning.
Possible cconsole log values: Severity = 0 (Information), 1 (Warning), 2 (Severe), 3 (Fatal)</Description>
<Type>%String</Type>
</Property>

<Property name="CConsoleSevereCodes">
<Description>
A comma separated list of codes that may be returned from the OS command
If the OS command returns a value found in CConsoleSevereCodes then all
output from the OS command will be logged to the cconsole.log as severe.
Possible cconsole log values: Severity = 0 (Information), 1 (Warning), 2 (Severe), 3 (Fatal)</Description>
<Type>%String</Type>
</Property>

<Method name="OnTask">
<Description>
A task to be used for scheduling OS commands from the 
System Management Portal Task Scheduler</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Set tStatus = $$$OK
	Try{
		#;Execute the OS command and the last '1' should cause the last line of tOutput
		#;to contain the status from the OS of the command execution ($? on unix %errorlevel% on windows).
		#; TODO: figure out how to get real %errorlevel% back from windows calls.
		Set tStatus = ##class(zCustom.TC.Task.Util.OSCommand).ExecutePipe(..OSCommand,.tOutput,1,1)
		If (..WriteToCConsole=1){
			#;Get the OS return status by looking at the last line of the returned output
			#;The last line of the output will look something like:
			#;OS command exit status=1
			Set tOSStatus = $Piece(tOutput.GetAt(tOutput.Count()),"=",2)
			Set tLogLevel=..SetLogLevel(tOSStatus)
			For i=1:1:tOutput.Count(){
				Do ##class(%SYS.System).WriteToConsoleLog(tOutput.GetAt(i),,tLogLevel)
			}
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="SetLogLevel">
<Description>
Looks at the OS return code and checks is the return code is either in the 
CConsoleWarnCodes or CConsoleSevereCodes settings and if it is returns the
appropriate flag number.  If it isn't then 0 or the information flag is returned.</Description>
<FormalSpec>pOSStatus:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tLogLevel = 0
	For i=1:1:$L(..CConsoleWarnCodes,","){Set:$P(..CConsoleWarnCodes,",",i)=pOSStatus tLogLevel=1}
	For i=1:1:$L(..CConsoleSevereCodes,","){Set:$P(..CConsoleSevereCodes,",",i)=pOSStatus tLogLevel=2}
	Quit tLogLevel
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.Purge">
<Super>%SYS.Task.Definition</Super>
<TimeChanged>63336,38682.488423</TimeChanged>
<TimeCreated>63336,38682.488423</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/Purge.xml#1 $</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;
This is defined in subclasses.</Description>
<Type>STRING</Type>
<Default>TrakCare Purges</Default>
</Parameter>

<Property name="WebsysMonitorDataPurge">
<Description>
If true the Websys.Monitor table will be purged only maintaining the
number of days set in WebsysMonitorDataDaysToKeep.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="WebsysMonitorDataDaysToKeep">
<Type>%Integer</Type>
<InitialExpression>30</InitialExpression>
</Property>

<Property name="WebsysMonitorDataJournalOff">
<Description>
If true the Journaling will be disabled for the Websys.Monitor table 
purge.  This should only be selected if the Monitor database is not shadowed.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="WebsysMonitorLicensePurge">
<Type>%Boolean</Type>
</Property>

<Property name="WebsysMonitorLicenseDaysToKeep">
<Type>%Integer</Type>
<InitialExpression>30</InitialExpression>
</Property>

<Property name="WebsysMonitorLicenseJournalOff">
<Description>
If true the Journaling will be disabled for the Websys.MonitorLicense table 
purge.  This should only be selected if the Monitor database is not shadowed.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="PrintHistoryPurge">
<Type>%Boolean</Type>
</Property>

<Property name="PrintHistoryDaysToKeep">
<Type>%Integer</Type>
<InitialExpression>30</InitialExpression>
</Property>

<Property name="PrintHistoryJournalOff">
<Description>
If true the Journaling will be disabled for the PrintHistory table 
purge.  This should only be selected if the Data database is not shadowed.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SSHL7Purge">
<Type>%Boolean</Type>
</Property>

<Property name="SSHL7DaysToKeep">
<Type>%Integer</Type>
<InitialExpression>360</InitialExpression>
</Property>

<Property name="SSHL7JournalOff">
<Description>
If true the Journaling will be disabled for the PrintHistory table 
purge.  This should only be selected if the HL7 database is not shadowed.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="OnTask">
<Description>
A task to purge monitoring statistics, monitor licenses, print history and HL7
It is assumed that the monitor database is not journaled as the shadow should
not have live monitoring stats but should be local to the shadow.  As such
journalling is turned off for the monitor purges.
This process writes out a status message to the cconsole.log upon completion</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Set tStatus = $$$OK
	Try{
		#;Turn of journaling for the monitor purges
		#;The assumption is that journaling is not on for the monitor database
		If (..WebsysMonitorDataPurge=1){
			If ((..WebsysMonitorDataJournalOff=1)&&($$CURRENT^%NOJRN=1)){
				Do DISABLE^%NOJRN
			}Else{
				Do ENABLE^%NOJRN
			}
			Set tStatus = ..websysMonitorPurge()
		}
		If (..WebsysMonitorLicensePurge=1){
			If ((..WebsysMonitorLicenseJournalOff=1)&&($$CURRENT^%NOJRN=1)){
				Do DISABLE^%NOJRN
			}Else{
				Do ENABLE^%NOJRN
			}
			Set tStatus = ..websysMonitorLicensePurge()
		}
		#;Journaling on so the shadow server will get the purge also
		#;otherwise the shadow database will keep growing and never be purged.
		If (..PrintHistoryPurge=1){
			If ((..PrintHistoryJournalOff=1)&&($$CURRENT^%NOJRN=1)){
				Do DISABLE^%NOJRN
			}Else{
				Do ENABLE^%NOJRN
			}
			Set tStatus = ..websysPrintHistoryPurge()
		}
		If (..SSHL7Purge=1){
			If ((..SSHL7JournalOff=1)&&($$CURRENT^%NOJRN=1)){
				Do DISABLE^%NOJRN
			}Else{
				Do ENABLE^%NOJRN
			}
			Set tStatus = ..SSHL7Purge()
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	#;Make sure journaling is enabled on the way out if it is not already
	DO:($$CURRENT^%NOJRN=0) ENABLE^%NOJRN
	Quit tStatus
]]></Implementation>
</Method>

<Method name="websysMonitorPurge">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set (tDate,tTime,tIndex)=""
	Set tPurgeCount = 0
	Try{
		For { Set tDate=$O(^websys.MonitorI("DateTime",tDate)) Quit:((tDate>=(+$H-..WebsysMonitorDataDaysToKeep))||(tDate=""))
			For { Set tTime=$O(^websys.MonitorI("DateTime",tDate,tTime)) Quit:tTime=""
				For { Set tIndex=$O(^websys.MonitorI("DateTime",tDate,tTime,tIndex)) Quit:tIndex=""
					&sql(Delete From websys.monitor Where Id = :tIndex)
					If (SQLCODE=0){
						Set tPurgeCount = tPurgeCount + 1
					}Else{
						$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to delete websys.monitor record (ID = "_tIndex_") SQLCODE="_SQLCODE _ ". Purge aborted"))
					}
				}
			}
		}
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysMonitorPurge purged "_ tPurgeCount _" records succuessfully.",,0)
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Do:(tPurgeCount>0) ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysMonitorPurge purged "_ tPurgeCount _" records succuessfully.",,0)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysMonitorPurge purge failed (ID = "_tIndex_"): "_tStatus,,2)		
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="websysMonitorLicensePurge">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set (tDate,tIndex,tTime)=""
	Set tPurgeCount = 0
	#;TODO -- Add check to look for old index format ^websys.MonitorLicenseI("DateIndex",tDate)
	#; and if an old index is found need to kill and rebuild
	Try{
		For { Set tDate=$O(^websys.MonitorLicenseI("DateTime",tDate)) Quit:((tDate>=(+$H-..WebsysMonitorLicenseDaysToKeep))||(tDate=""))
			For { Set tTime=$O(^websys.MonitorLicenseI("DateTime",tDate,tTime)) Quit:tTime=""
				For { Set tIndex=$O(^websys.MonitorLicenseI("DateTime",tDate,tTime,tIndex)) Quit:tIndex=""
					&sql(Delete From websys.MonitorLicense Where Id = :tIndex)
					If (SQLCODE=0){
						Set tPurgeCount = tPurgeCount + 1
					}Else{
						$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to delete websys.MonitorLicense record (ID = "_tIndex_") SQLCODE="_SQLCODE _ ". Purge aborted"))
					}
				}
			}
		}
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysMonitorLicensePurge purged "_ tPurgeCount _" records succuessfully.",,0)
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysMonitorLicensePurge purged "_ tPurgeCount _" records succuessfully.",,0)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysMonitorLicensePurge purge failed (ID = "_tIndex_"): "_tStatus,,2)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="websysPrintHistoryPurge">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set (tDate,tTime,tIndex)=""
	Set tPurgeCount = 0
	Try{
		For { Set tDate=$O(^websys.PrintHistoryI("PrintDateIndex",tDate)) Quit:((tDate>=(+$H-..PrintHistoryDaysToKeep))||(tDate=""))
			For { Set tTime=$O(^websys.PrintHistoryI("PrintDateIndex",tDate,tTime)) Quit:tTime=""
				For { Set tIndex=$O(^websys.PrintHistoryI("PrintDateIndex",tDate,tTime,tIndex)) Quit:tIndex=""
					&sql(Delete from websys.PrintHistory Where Id = :tIndex)
					If (SQLCODE=0){
						Set tPurgeCount = tPurgeCount + 1
					}Else{
						$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to delete websys.PrintHistory record (ID = "_tIndex_") SQLCODE="_SQLCODE _ ". Purge aborted"))
					}
				}
			}
		}
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysPrintHistoryPurge purged "_ tPurgeCount _" records succuessfully.",,0)
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysPrintHistoryPurge purged "_ tPurgeCount _" records succuessfully.",,0)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysPrintHistoryPurge purge failed (ID = "_tIndex_"): "_tStatus,,2)		
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="SSHL7Purge">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set (tLink,tDate,tIndex)=""
	Set tPurgeCount = 0
	Try{
		For { Set tLink=$O(^SSHL7(tLink)) Quit:tLink=""
			#;Null out tDate so it starts at the beginning of the tLink node
			Set tDate =""
			For { Set tDate=$O(^SSHL7(tLink,"TRACE",tDate)) Quit:((tDate>=(+$H-..SSHL7DaysToKeep)||(tDate="")))
				#;The SQL way of doing it
				#;Not used so as to more closely replicate what is currently done
				#;and building the Row id like this seems hackish
				#; -- Also Untested --------------
				For { Set tIndex=$O(^SSHL7(tLink,"TRACE",tDate,tIndex)) Quit:tIndex=""
					#;Set tRowId = tLink _"||"_tDate_"||"_tIndex
					#;&sql(Delete from SQLUser.ss_hl7trace Where HL7MT_RowId = :tRowId)
					#;If (SQLCODE=0){
						Set tPurgeCount = tPurgeCount + 1
					#;}Else{
					#;	$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to delete websys.PrintHistory record (ID = "_tRowId_") SQLCODE="_SQLCODE _ ". Purge aborted"))
					#;}
				}
				Kill ^SSHL7(tLink,"TRACE",tDate)
			}
		}
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".SSHL7Purge purged "_ tPurgeCount _" records succuessfully.",,0)
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".SSHL7Purge purged "_ tPurgeCount _" records succuessfully.",,0)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".SSHL7Purge purge failed (Link = "_tLink_", Date="_tDate_"): "_tStatus,,2)		
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="SSHL7PurgeSQL">
<Description>
////////////////////     End of used code at this point 9-Nov-11 //////////////////
Alternative SQL way of doing the HL7 Purge.
Not used and not tested.</Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tIndex=""
	Set tPurgeCount = 0
	Set tOlderThan = +$H-..SSHL7DaysToKeep
	Try{
		#;Cursor used v. straight delete to prevent
		#;too many rows from being deleted at once as that will
		#;cause a full table lock and pause interface processing.
		&sql(DECLARE CurSSHL7 CURSOR FOR
			 SELECT HL7MT_RowId
			 INTO :tIndex
			 FROM SQLUser.SS_HL7Trace
			 WHERE HL7MT_Date <=:tOlderThan
		)
		&sql(OPEN CurSSHL7)
		For { &sql(FETCH CurSSHL7) Quit:SQLCODE
			&sql(Delete from SQLUser.SS_HL7Trace Where HL7MT_RowId = :tIndex)
			If (SQLCODE=0){
				Set tPurgeCount = tPurgeCount + 1
			}Else{
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to delete SS_HL7Trace record SQLCODE="_SQLCODE _ ". Purge aborted"))
			}
		}
		&sql(CLOSE CurSSHL7)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".SSHL7PurgeSQL purged "_ tPurgeCount _" records succuessfully.",,0)
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".SSHL7PurgeSQL purged "_ tPurgeCount _" records succuessfully.",,0)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".SSHL7PurgeSQL purge failed: "_tStatus,,2)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="websysPrintHistoryPurgeSQL">
<Description>
Alternative way of purging Print History
Not used and not tested.</Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tIndex=""
	Set tPurgeCount = 0
	Set tOlderThan = +$H-..PrintHistoryDaysToKeep
	Try{
		&sql(DECLARE CurPrintHistory CURSOR FOR
			 SELECT ID
			 INTO :tIndex
			 FROM websys.PrintHistory
			 WHERE PrintDate <=:tOlderThan
		)
		&sql(OPEN CurPrintHistory)
		For { &sql(FETCH CurPrintHistory) Quit:SQLCODE
			&sql(Delete from websys.PrintHistory Where Id = :tIndex)
			If (SQLCODE=0){
				Set tPurgeCount = tPurgeCount + 1
			}Else{
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to delete websys.PrintHistory record SQLCODE="_SQLCODE _ ". Purge aborted"))
			}
		}
		&sql(CLOSE CurPrintHistory)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysPrintHistoryPurge purged "_ tPurgeCount _" records succuessfully.",,0)
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysPrintHistoryPurge purged "_ tPurgeCount _" records succuessfully.",,0)
		Do ##class(%SYS.System).WriteToConsoleLog(..%ClassName(1) _".websysPrintHistoryPurge purge failed: "_tStatus,,2)
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.ShadowCheck">
<Description>
A task used to back up check the status of the shadow server.</Description>
<IncludeCode>%sySite,EnsUtil</IncludeCode>
<Super>zCustom.TC.Task.GenericEmail</Super>
<TimeChanged>63336,39408.427488</TimeChanged>
<TimeCreated>63336,38731.493267</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/ShadowCheck.xml#1 $</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;</Description>
<Type>STRING</Type>
<Default>Shadow Status Check</Default>
</Parameter>

<Parameter name="WebServiceClass">
<Type>%String</Type>
<Default>zCustom.TC.Task.WS.ShadowCheck.cls</Default>
</Parameter>

<Parameter name="WebServiceClientClass">
<Type>%String</Type>
<Default>zCustom.TC.Task.WSClient.ShadowCheckSoap</Default>
</Parameter>

<Parameter name="WebMethod">
<Type>%String</Type>
<Default>GetShadowStatus</Default>
</Parameter>

<Parameter name="EndTimeCheck">
<Type>%String</Type>
<Default>END GLOBAL DATA</Default>
</Parameter>

<Property name="ShadowServer">
<Description>
The IP or Host name of the shadow server</Description>
<Type>%String</Type>
</Property>

<Property name="ShadowServerWebPort">
<Description>
The port of the shadow server web server (for the internal/ensemble web server)</Description>
<Type>%String</Type>
</Property>

<Property name="WSNamespace">
<Description>
The namespace that hosts the web service.  Used to construct the web service call</Description>
<Type>%String</Type>
</Property>

<Property name="TimeCheckGlobal">
<Description>
The name of the global that is used to set with the time for the primary check
</Description>
<Type>%String</Type>
<InitialExpression>"^TrakDashboard(""Shadowing"",""1""):User"</InitialExpression>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Method name="OnTask">
<Description>
Performs several validation tasks to check if shadowing is working as expected
and then sends an email to distribute the report.
Validation tasks include:
1.) Collects a report from the shadow instance via web service that includes the
   results from the SYS.Shadowing.Shadow:Progress query and errors are reported 
   from that query the results of the SYS.Shadowing.Shadow:Errors query
2.) Compares the values returned in the shadow report against the shadowed databases
   values for all the globals found in TimeCheckGlobal.  This check is purely a time 
   based check where the TimeCheckGlobal is set with the current date and time
   at the end of each run.  When the next run happens the value in the shadow instance
   (returned in the report) should match if shadowing is working correctly</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tLocalTimeGlobal = ""
	Set tOrigNS = $ZU(5)
	Try{
		#;Call web service
		Set tStatus = ..GatherResults(.tWSResponse)
		If (tStatus'=$$$OK) {
			#; unable to make web service call and need to notify someone that
			#; there was an issue with the monitoring.
			Set tFailWSStream = ##class(%Stream.TmpCharacter).%New()
			Do tFailWSStream.WriteLine("Error attempting to collect shadow server information.")
			Do tFailWSStream.WriteLine()
			Do tFailWSStream.WriteLine("Shadow Server: "_..ShadowServer)
			Do tFailWSStream.WriteLine("Shadow Server Web Port: "_ ..ShadowServerWebPort)
			Do tFailWSStream.WriteLine("Error: " _ $$$StatusDisplayString(tStatus))
			Do tFailWSStream.Rewind()
			Set tSC = ..EmailReport(tFailWSStream)
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Shadow check was unable to call the shadow server web service: "_$$$StatusDisplayString(tStatus)))
		}Else{
			Set tWSResponse.LineTerminator = $c(10)   //TODO: HACK - this is $c(13) for some reason on 182
			Set tStatus = ..CheckTimeStamps(.tWSResponse,.tTimeCheck)
			Set tStatus = ..EmailReport(tWSResponse,tTimeCheck)
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="EmailReport">
<FormalSpec>pReportStream:%Stream.TmpCharacter,pTimeCheck:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tTempStream = ##class(%Stream.TmpCharacter).%New()
	Do:pTimeCheck'="" tTempStream.WriteLine(pTimeCheck)
	Do:pTimeCheck'="" tTempStream.WriteLine()
	Do tTempStream.Write(pReportStream.Read())
	Do tTempStream.Rewind()
	Quit ..SendEmail(tTempStream)
]]></Implementation>
</Method>

<Method name="CheckTimeStamps">
<Description>
Forwards through the stream comparing the time check globals from the stream 
against the values on the shadowed databases and sets the shadowed databases
time check globals to the current date and time.</Description>
<FormalSpec><![CDATA[&pReport:%Stream.TmpCharacter,&pTimeCheckResults:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tLocalTimeGlobal = ""
	Set tOrigNS = $ZU(5)
	Try{
		Set tRemoteTimes = ..LoadTimeChecks(.pReport)
		#;Loop over the TimeCheckGlobal: Format <GlobalName>:<namespace>~<GlobalName>:<namespace>~
		#;So the time check global can vary by namespace and all shadowed databases can be checked
		For i=1:1:$L(..TimeCheckGlobal,"~"){
			Set tArrayKey = $P(..TimeCheckGlobal,"~",i)
			Set tTimeCheckGlobal = $P(tArrayKey,":",1)
			Set tNamespace = $P(tArrayKey,":",2)
			Set tRemoteTime = tRemoteTimes.GetAt(tArrayKey)
			zn tNamespace
			If (tRemoteTime=""){
				Set pTimeCheckResults = pTimeCheckResults_"Shadow global "_tTimeCheckGlobal_" not checked for "_tNamespace_"." _$C(13,10)
				Set pTimeCheckResults = pTimeCheckResults_"Not check probably because it is the initial check.  The next check should have the global set." _$C(13,10)
			}Else{
				Set tLocalTimeGlobal = $G(@tTimeCheckGlobal,0)
				#;Compare Time global
				If (tRemoteTime'=tLocalTimeGlobal){
					#; If they don't match then the shadow is behind
					Set pTimeCheckResults = pTimeCheckResults_" Shadow value ("_$ZDT(tRemoteTime)_") for "_tTimeCheckGlobal _"does not match source value "_$ZDT(tLocalTimeGlobal)_"."_$C(13,10)
				}Else{
					#; If they do match then the shadow is in sync
					Set pTimeCheckResults = pTimeCheckResults_" The Shadow and Source instance are in sync for "_tNamespace_":"_tTimeCheckGlobal _"="_$ZDT(tLocalTimeGlobal)_"."_$C(13,10)
				}
				#; And reset the time check global for the next check
			}
			Set @tTimeCheckGlobal= $H
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	zn tOrigNS		
	Quit tStatus
]]></Implementation>
</Method>

<Method name="LoadTimeChecks">
<Description><![CDATA[
Forwards through the report to get the Remote time check values.
This method does not Rewind the report intentionally so the 
Time checks are not a part of the final sent report.
The time check formats are expected to be: <GlobalName>:<namespace>=<value>
and the end of the time checks is signified by the value in ..#EndTimeCheck
The returned array will have <GlobalName>:<namespace> as the key and 
<value> as the value.]]></Description>
<FormalSpec><![CDATA[&pReport:%Stream.TmpCharacter]]></FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
	Set tReturnArray = ##class(%ArrayOfDataTypes).%New()
	Set tOneLine = pReport.ReadLine()
	While ((tOneLine'="")&&(tOneLine'=..#EndTimeCheck)){
		Do tReturnArray.SetAt($P(tOneLine,"=",2),$P(tOneLine,"=",1))
		Set tOneLine = pReport.ReadLine()
	}
	Quit tReturnArray
]]></Implementation>
</Method>

<Method name="GatherResults">
<Description>
Uses the EnsLib.SOAP.OutboundAdapter to make a call to the web service
that should be hosted on the shadow server.  The web service will return
a stream that contains the report and global values from the shadow server.</Description>
<FormalSpec><![CDATA[&pResponse:%Stream.TmpCharacter]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		Set pResponse = ##class(%Stream.TmpCharacter).%New()
		Set tAdapter = ##class(EnsLib.SOAP.OutboundAdapter).%New()
		Set tAdapter.WebServiceURL = "http://"_..ShadowServer_":"_..ShadowServerWebPort_"/csp/"_..WSNamespace_"/"_ ..#WebServiceClass
		Set tAdapter.WebServiceClientClass = ..#WebServiceClientClass
		#;Set tRequest = ##class(zCustom.TC.Task.WS.ShadowCheckRequest).%New()
		#;Set tRequest.TimeGlobal = ..TimeCheckGlobal
		#;Set tRemoteCreds =  
		#;Set tAdapter.SOAPCredentials = tRemoteCreds
		#;Set tAdapter.Credentials = tRemoteCreds
		#;Set tAdapter.ProxyHTTPS = 0
		Set tSC = tAdapter.InvokeMethod(..#WebMethod,.pResponse,..TimeCheckGlobal)
		Do pResponse.Rewind()
	} Catch ex { 
		Set tSC=ex.AsStatus() 
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.TrakMonitorInfoToFile">
<Description>
Task to generate several monitoring files that are monitored by Nagios.
If the files do not exist they will be created if they do exist they will be over-written
with each run of task.
Each file has an header which contains: Hostname^ApplicationNamespace^Date^Time
	Date and Time are in cache' format
The following files are generated for (TCMon is the ..FilePrefix):
TrakPrintStats is checked
TCMon_Print.mon
	1) Error current day
	2) Print Processes Printed Last Hour
	3) Print Processes In Progress
	4) Print Processes Printed Last Minute
	5) Print Processes In Waiting

TrakInterfaceStats is checked
TCMon_Int.mon
	Each row is an interface defined with IWB
	The values are 
	InterfaceName^Status^NumberOfMessagesInQueue

TrakLicenseStats is checked
TCMon_Lic.mon
	Number of used TrakCare Licenses
		Interger

ErrorStats is checked
TCMon_DayAppError.mon
	Number of TrakCare application namespace errors 
    Interger

TrakPerformanceStats is checked
TCMon_Perf.mon
	Number of TrakCare Component which are performing slower than expected
	Interger

TrakEPSProductionStatus is checked
TCMon_EPSStatus.mon
The status of the production for the namespace where the task was run
		Integer where:
         1=$$$eProductionStateRunning
         2=$$$eProductionStateStopped
         3=$$$eProductionStateSuspended
         4-$$$eProductionStateTroubled

TrakEPSOldestMessage is checked
TCMon_EPSEnsMsg.mon
	An Integer that represent the age in days of the oldest message in the Ensemble message database

TrakEPSDebug is checked
TCMon_EPSDebug.mon
	An Integer that indicates the Zen Debug flag (^CacheTemp.ZEN("DebugZen","NoDelete"))</Description>
<IncludeCode>EnsUtil</IncludeCode>
<Super>%SYS.Task.Definition</Super>
<TimeChanged>63336,52024.824282</TimeChanged>
<TimeCreated>63336,38782.998806</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/TrakMonitorInfoToFile.xml#1 $</Default>
</Parameter>

<Parameter name="TaskName">
<Description>
This defines the user-visible name of this task;
This is defined in subclasses.</Description>
<Type>STRING</Type>
<Default>Monitoring Info to Files</Default>
</Parameter>

<Property name="LogPath">
<Description>
The path to which the monitoring files will be saved to.</Description>
<Type>%String</Type>
<InitialExpression>"/var/TCMon/"</InitialExpression>
</Property>

<Property name="FilePrefix">
<Description>
Prefix to be added to all generated files.</Description>
<Type>%String</Type>
<InitialExpression>"TCMon"</InitialExpression>
</Property>

<Property name="WriteSuccessfulRunToCConsole">
<Description>
If true the results are written to the cconsole.log file
With the assumption that nagios or some other monitoring tool will be
used to alert when error occur.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="TrakPrintStats">
<Description>
The type of server metrics to gather.  Either Database (1) for 
a data server or Print(2) for an Ensemble Print Server.
Property ServerType As %String(DISPLAYLIST = ",Database,Print", VALUELIST = ",1,2") [ InitialExpression = "1" ];</Description>
<Type>%Boolean</Type>
</Property>

<Property name="TrakInterfaceStats">
<Type>%Boolean</Type>
</Property>

<Property name="TrakLicenseStats">
<Type>%Boolean</Type>
</Property>

<Property name="TrakEPSDebug">
<Type>%Boolean</Type>
</Property>

<Property name="TrakEPSProductionStatus">
<Type>%Boolean</Type>
</Property>

<Property name="TrakEPSOldestMessage">
<Type>%Boolean</Type>
</Property>

<Property name="TrakPerformanceStats">
<Type>%Boolean</Type>
</Property>

<Property name="CSPSessionCount">
<Type>%Boolean</Type>
</Property>

<Property name="EnsembleUptime">
<Type>%Boolean</Type>
</Property>

<Property name="ProductionUptimes">
<Type>%Boolean</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Not used as the age reported is not accurate

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Property TransactionAge As %Boolean;

]]></Content>
</UDLText>

<Property name="ErrorStats">
<Type>%Boolean</Type>
</Property>

<Property name="TrakPerformanceThreshold">
<Description>
The threshold used to gather a count of components that are running slow.</Description>
<Type>%Float</Type>
<InitialExpression>2.5</InitialExpression>
</Property>

<Property name="TrakPerformanceSampleSize">
<Description>
Number of seconds to include in the sample size queries for 
components over the threshold provided in TrakPerformanceThreshold.</Description>
<Type>%Integer</Type>
<InitialExpression>300</InitialExpression>
</Property>

<Method name="IsPathValid">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set ..LogPath = ##class(%File).NormalizeDirectory(..LogPath)
	Quit ##class(%File).DirectoryExists(..LogPath)
]]></Implementation>
</Method>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	Set tStatus = $$$OK
	Try{
		If (..IsPathValid()'=1)  $$$ThrowStatus($$$ERROR($$$GeneralError,"Aborting '" _..#TaskName_"' due to missing directory: "_..LogPath))
		If (..TrakPrintStats=1){
			Set tPrintArray = ##class(zCustom.TC.Task.Util.TrakMetrics).GetPrintStats()
			Set tStatus = ..WritePrintStatsToFile(tPrintArray)
		}
		If (..TrakInterfaceStats=1){
			Set tIntArray = ##class(zCustom.TC.Task.Util.TrakMetrics).GetInterfacesStatus()
			Set tStatus = ..WriteArrayStatsToFile(tIntArray,"Int")
		}
		If (..TrakLicenseStats=1){
			Set tLicenseCount = ##class(zCustom.TC.Task.Util.TrakMetrics).Licenses()
			Set tStatus = ..WriteStatToFile(tLicenseCount,"Lic")
		}
		If (..ErrorStats=1){
			Set tAppErrorCount = ##class(zCustom.TC.Task.Util.EnsembleMetrics).DayAppError()
			Set tStatus = ..WriteStatToFile(tAppErrorCount,"DayAppError")
		}
		If (..EnsembleUptime=1){
			Set tCacheUptime = ##class(zCustom.TC.Task.Util.EnsembleMetrics).GetCacheUptime()
			Set tStatus = ..WriteStatToFile(tCacheUptime,"EnsembleUptime")
		}
		If (..ProductionUptimes=1){
			Set tStatus = ##class(zCustom.TC.Task.Util.EnsembleMetrics).GetProductionUptimes(.tUptimeStream,0)
			Set tStatus = ..WriteStreamStatsToFile(tUptimeStream,"ProductionUptimes")
		}
		If (..CSPSessionCount=1){
			Set tCSPSessionCount = ##class(zCustom.TC.Task.Util.EnsembleMetrics).GetCSPSessionCount()
			Set tStatus = ..WriteStatToFile(tCSPSessionCount,"CSPSessionCount")
		}
		/*  Not used as the age reported is not accurate.
		If (..TransactionAge=1){
			Set tOldestTransInSecs = ##class(zCustom.TC.Task.Util.EnsembleMetrics).GetAgeOfOldestTransaction()
			Set tStatus = ..WriteStatToFile(tOldestTransInSecs,"OldestTransInSeconds")
		}
		*/
		If (..TrakPerformanceStats=1){
			#;Returns an array with component name as the key and average as the value
			#;Only outputting the count to mimic the existing code so as not to break the
			#;Existing nagios scripts.
			Set tPerfArray = ##class(zCustom.TC.Task.Util.TrakMetrics).GetPerformanceMonitorCount(..TrakPerformanceSampleSize,..TrakPerformanceThreshold)
			Set tStatus = ..WriteStatToFile(tPerfArray.Count(),"Perf")
			
		}
		If (..TrakEPSDebug=1){
			Set tStatus = ..WriteStatToFile(##class(zCustom.TC.Task.Util.TrakMetrics).GetEPSDebug(),"EPSDebug")
		}
		If (..TrakEPSProductionStatus=1){
			Set tStatus = ..WriteStatToFile(##class(zCustom.TC.Task.Util.TrakMetrics).GetEPSProductionStatus(),"EPSStatus")
		}
		If (..TrakEPSOldestMessage=1){
			Set tStatus = ..WriteStatToFile(##class(zCustom.TC.Task.Util.TrakMetrics).GetEPSDaysOnLine(),"EPSEnsMsg")
		}
		i ..WriteSuccessfulRunToCConsole Do ##class(%SYS.System).WriteToConsoleLog(..#TaskName_" successfully run.  Log files are available in "_ ..LogPath,"",0)
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Do ##class(%SYS.System).WriteToConsoleLog("Error in "_..#TaskName_": "_ $$$StatusDisplayString(tStatus),"",1)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="WriteStatToFile">
<Description>
Writes pStat to a file named: ..FilePrefix_pFileType.mon
File also includes a header line of: Hostname^Namespace^CacheFormatHour^CacheFormatTime</Description>
<FormalSpec>pStat:%String,pFileType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		Set tFile = ..GetFileStream(pFileType)
		Set tStatus = tFile.WriteLine(pStat)
		Set tStatus = tFile.%Save()
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetFileStream">
<Description>
Simple wrapper to create a file stream and write a header line to the file that contains:
Hostname^Namespace^CacheFormatHour^CacheFormatTime
The location of the file is determined by ..LogPath
The name of the file is ..FilePrefix_pFileType.mon</Description>
<FormalSpec>pFileType:%String</FormalSpec>
<ReturnType>%Stream.FileCharacter</ReturnType>
<Implementation><![CDATA[
	Set tFile = ##class(%Stream.FileCharacter).%New()
	Set tFile.Filename = ..LogPath_..FilePrefix_"_"_pFileType_".mon"
	Set tStatus = tFile.%Open()
	Set tStatus = tFile.WriteLine($ZU(110)_"^"_$ZU(5)_"^"_$P($H,"^",2)_"^"_$P($H,"^",1))
	Quit tFile
]]></Implementation>
</Method>

<Method name="WritePrintStatsToFile">
<Description>
Must be Print stats specific to ensure the order of the stats remain the same
as the original code.</Description>
<FormalSpec>pArray:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		Set tFile = ..GetFileStream("Print")
		Set tStatus = tFile.WriteLine(pArray.GetAt("TodaysErrorCount"))
		Set tStatus = tFile.WriteLine(pArray.GetAt("LastHourPrintedRequests"))
		Set tStatus = tFile.WriteLine(pArray.GetAt("InProgress"))
		Set tStatus = tFile.WriteLine(pArray.GetAt("LastMinuteRequests"))
		Set tStatus = tFile.WriteLine(pArray.GetAt("Wait"))
		Set tStatus = tFile.%Save()
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="WriteArrayStatsToFile">
<Description>
Writes an array of stats to a file.
This loops over the array and writes one line for each item in the array like:
key_pDelimiter_value </Description>
<FormalSpec>pArray:%ArrayOfDataTypes,pFileType:%String,pDelimiter:%String="^"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		Set tFile = ..GetFileStream(pFileType)
		Set tInterface = ""
		Set tInterfaceStats = pArray.GetNext(.tInterface) 
		While (tInterface'=""){
			Set tStatus = tFile.WriteLine(tInterface_pDelimiter_tInterfaceStats)
			Set tInterfaceStats = pArray.GetNext(.tInterface) 
		}
		Set tStatus = tFile.%Save()
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="WriteStreamStatsToFile">
<Description>
Writes an Stream of stats to a file.
This loops over the array and writes one line for each item in the array like:
key_pDelimiter_value </Description>
<FormalSpec>pStream:%Stream.TmpCharacter,pFileType:%String,pDelimiter:%String="^"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		Set tFile = ..GetFileStream(pFileType)
		Do pStream.Rewind()
		Set tStatus = tFile.Write(pStream.Read())
		Set tStatus = tFile.%Save()
	}Catch(ex){Set tStatus = ex.AsStatus()}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<FormalSpec>pServerType:%Integer=1,pPath:%String="/home/client"</FormalSpec>
<Implementation><![CDATA[

	Set m = ##class(zCustom.TC.Task.TrakMonitorInfoToFile).%New()
	Set m.LogPath = pPath
	Set m.ServerType=pServerType
	W m.OnTask()
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.Util.Email">
<Description>
A supporting Util class to send emails.  Used by a couple of the
tasks.</Description>
<IncludeCode>%sySite</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>63336,38846.925033</TimeChanged>
<TimeCreated>63336,38846.925033</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/Util/Email.xml#1 $</Default>
</Parameter>

<Property name="SMTPServer">
<Type>%String</Type>
</Property>

<Property name="SMTPPort">
<Type>%Integer</Type>
<InitialExpression>25</InitialExpression>
</Property>

<Property name="EMPCredentials">
<Description>
The name of the Ensemble Management Portal credentals that can
be used to access the SMTP server.  If this is set the value will
be used to authenticate with the SMTP server.  If this is not
set then the values in SMTPUser and SMTPPassword will be used
to authenticate to the SMTP server.</Description>
<Type>%String</Type>
</Property>

<Property name="SMTPUser">
<Description>
If the EMPCredentials is not set this is used as the username
to authenticate with the SMTP server.</Description>
<Type>%String</Type>
</Property>

<Property name="SMTPPassword">
<Description>
If the EMPCredentials is not set this is used as the password
to authenticate with the SMTP server.</Description>
<Type>%String</Type>
</Property>

<Property name="SSLConfig">
<Description>
The name of the SSL configuration found in the System Management Portal
to send email over SSL.  If this is null it is assumed that mail can be 
sent without the use of SSL.</Description>
<Type>%String</Type>
</Property>

<Property name="FromEmailAddress">
<Type>%String</Type>
</Property>

<Property name="EmailSubject">
<Type>%String</Type>
<InitialExpression>"Automated Shadowing Report"</InitialExpression>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Property name="ToEmailAddresses">
<Description>
A comma seperated list of email addresses.  Every email address in the
list will receive sent emails.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Method name="SendEmail">
<FormalSpec>pEmailText:%Stream.TmpCharacter,pAttachFileName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try{
		If (..CanSendEmail()=1) {
			Set tSMTP = ##class(%Net.SMTP).%New()
			Set tAuth = ##class(%Net.Authenticator).%New() ; use default authentication list
			If (..EMPCredentials '= "") {
				Set tCred = ##class(Ens.Config.Credentials).%OpenId(..EMPCredentials)
				Set tAuth.UserName = tCred.Username
				Set tAuth.Password = tCred.Password
			}Else{
				Set tAuth.UserName = ..SMTPUser
				Set tAuth.Password = ..SMTPPassword
			}
			Set tSMTP.authenticator = tAuth
			Set tSMTP.smtpserver = ..SMTPServer
			Set tSMTP.port = ..SMTPPort
			#;If SMTPSSL is set assume outbound mail is over SSL
			#;The value of SMTPSSL is the name of a [Home] > [Security Management] > [SSL/TLS Configurations] 
			#; Configuration item
			If ..SSLConfig'=""{
				Set tSMTP.UseSTARTTLS=1
				Set tSMTP.SSLConfiguration=..SSLConfig
			}
			Set tStatus = ..CreateEmail(.tEmail,pEmailText,pAttachFileName)
			// Send the email
			If (tStatus=1) Set tStatus = tSMTP.Send(tEmail)

			// Clean up
			Kill tAuth, tSMTP, tEmail
		} Else {
			Set tStatus = 0
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CanSendEmail">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If ((..SMTPPort="")||(..SMTPServer="")||(..FromEmailAddress="")||(..ToEmailAddresses="")){
		Set tStatus = 0
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CreateEmail">
<FormalSpec><![CDATA[&pEmail:%Net.MailMessage,pEmailText:%Stream.TmpCharacter,pAttachFileName:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set pEmail = ##class(%Net.MailMessage).%New()
	Try{
			#;Set pEmail.Charset = "iso-8859-1"
			Set pEmail.From = ..FromEmailAddress
			Set pEmail.Subject = ..EmailSubject
			Do pEmail.TextData.Write(pEmailText.Read())
			Do pEmail.TextData.Write($char(13,10))
			Do pEmail.TextData.Write("NOTE: This is an automated email, please do not reply to this email.")
			Do pEmail.TextData.Write($char(13,10))
	
			// Get the list of addresses to mail the alert to and insert them into the message
			Set tCnt = 0
			For i=1:1:$L(..ToEmailAddresses,","){
				Do pEmail.To.Insert($P(..ToEmailAddresses,",",i))
				Set tCnt = tCnt + 1
			}
			#;Attach file if sent
			If ((pAttachFileName'="")&&(##class(%File).Exists(pAttachFileName))){
				Set tDir = ##class(%File).GetDirectory(pAttachFileName)
				Set tFileName = ##class(%File).GetFilename(pAttachFileName)
				Set tStatus = pEmail.AttachFile(tDir,tFileName,0)
			}
			// If no emails fail the Email creation 
			If (tCnt < 0) Set tStatus = 0
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.Util.EnsembleMetrics">
<Description>
A util class that collects TrakCare metrics for monitoring.</Description>
<IncludeCode>%sySite</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>63336,38893.530936</TimeChanged>
<TimeCreated>63336,38893.530936</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/Util/EnsembleMetrics.xml#1 $</Default>
</Parameter>

<Method name="GetAgeOfOldestTransaction">
<Description>
The accuracy of this is highly questionable.  The logic is to look at the
processes and look at the value of InTransaction.  InTransaction is the 
Journal Entry Id of the BeginTransaction entry.  However, the Timestamp
on the journal entry is not really the date and time that the journal
Entry was made.  From %SYS.Journal.Record class documentation for the TimeStamp field:
"Time stamp of the record (not necessarily the creation time of the record)"</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tOrigNS = $ZU(5)
	Set (tRoutine,tJournalId,tPID)=""
	Set tOldestTrans=0
	Try{
		ZN "%SYS"
		Set tResultSet = ##class(%ResultSet).%New()
		Do tResultSet.Prepare("SELECT Routine as R, InTransaction, PID "_
							"FROM %SYS.ProcessQuery " _
							"WHERE InTransaction<>0")
		Do tResultSet.Execute()
		While tResultSet.Next() {
			Set tRoutine = tResultSet.GetData(1)
			Set tJournalId = tResultSet.GetData(2)
			Set tPID = tResultSet.GetData(3)
			If tJournalId'=0 {
				Set tJournalTime = ""
				Set tJournalName = ##class(%SYS.Journal.System).GetCurrentFileName()
				While (tJournalName'=""){
					Set tJournalTime = ..GetDateTimeForJournalId(tJournalId,tJournalName)
					If (tJournalTime=""){
						Set tNextJournalStatus = ##class(%SYS.Journal.File).GetPrev(tJournalName,.tJournalName)
					}Else{
						Set tJournalName = ""
					}
				}
				If (tJournalTime '= ""){
					Set tSeconds = ..SecDiff(tJournalTime)
					Set:(tOldestTrans<tSeconds) tOldestTrans =tSeconds
				}
			}
		}
		Do tResultSet.Close()
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}
	ZN tOrigNS
	Quit tOldestTrans
]]></Implementation>
</Method>

<Method name="GetDateTimeForJournalId">
<Description>
A wrapper around the JRNUTIL routine calls as the COS class methods seemed to have
some locking issues on the journal files meaning there was no clear way to release
the lock on the open journals between runs.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pJournalId:%Integer,pJournalFileName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set (tJournalRecord,tReturn) = ""
	
	Set tStatus = $$OPENJRN^JRNUTIL(pJournalFileName)
	If (tStatus=$$$OK){ //Could not open journal no point trying the rest
		Set tStatus = $$USEJRN^JRNUTIL(pJournalFileName)
		Set tGetStatus = $$GETREC^JRNUTIL(pJournalId,.tJournalRecord)
		Set tStatus = $$CLOSEJRN^JRNUTIL(pJournalFileName)
		If (tGetStatus=$$$OK){
			#;NOTE This is not the time the entry was made
			#;If you look at the journal files "TimeStamp" is not
			#;really the time the entry was made and %SYS.Journal.Record also says this
			#;"Time stamp of the record (not necessarily the creation time of the record)"
			#;But it is the best we can do.
			#;w pJournalId_":"_pJournalFileName,!
			Set tReturn = $G(tJournalRecord(1,1,3),"")
			#;zw tJournalRecord
		}
	}
	Quit tReturn
]]></Implementation>
</Method>

<Method name="GetCSPSessionCount">
<Description>
Returns the sum of CSP Sessions for an instance 
Collected from ^%cspSession(tIndex)</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tIndex = ""
	Set tCSPSessionCount = 0
	For { Set tIndex=$O(^%cspSession(tIndex)) Quit:tIndex=""
		Set:tIndex'=0 tCSPSessionCount = tCSPSessionCount+1
	}
	Quit tCSPSessionCount
]]></Implementation>
</Method>

<Method name="GetCacheUptime">
<Description>
Gets the Uptime for the cache instance
E.g. Start Date=07 Dec 2011 12:05:33^Current Date=08 Dec 2011 11:40:21^Days=0^Hours=23^Minutes=34^Seconds=48</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; Get the total uptime of the instance in seconds
	Set tUptimeSeconds = $ZH
	Set tDays = tUptimeSeconds\86400
	Set tTotalSeconds = $p(tUptimeSeconds,".")#86400
	Set tToday = $H
	Set tCurrentTime = $P($ZDT(tToday)," ",2)
	Set tDayStart = +tToday-tDays
	Set tTimeStart = +$P(tToday,",",2)-tTotalSeconds
	If tTimeStart<0 S tDayStart = tDayStart - 1,tTimeStart = 86400-(tTotalSeconds-+$P(tToday,",",2))
	Set tHStartDate = tDayStart_","_tTimeStart
	Quit ..UptimeLine(tHStartDate,tToday)  //"Start Date=" _ $ZDT(tHStartDate,2)_"^Current Date=" _ $ZDT(tToday,2) _"^Days="_tDays_"^Hours="_tHours_"^Minutes="_tMinutes_"^Seconds="_tSeconds
]]></Implementation>
</Method>

<Method name="UptimeLine">
<Description>
Prints out a standard 'Uptime' line given two dates in $H format.
Example output: 
Start Date=07 Dec 2011 12:05:33^Current Date=08 Dec 2011 11:30:17^Days=0^Hours=23^Minutes=24^Seconds=44</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pHStartDate:%String,pHEndDate:%String=$H</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSeconds = ..SecDiff(pHStartDate,pHEndDate)
	Set tDays = tSeconds\86400
	Set tHours = tSeconds#86400\3600
	Set tMinutes = ((tSeconds#86400)-(tHours*3600))\60
	Set tSeconds = (tSeconds#86400)-(tHours*3600) - (tMinutes*60)
	Quit "Start Date=" _ $ZDT(pHStartDate,2)_"^Current Date=" _ $ZDT(pHEndDate,2) _"^Days="_tDays_"^Hours="_tHours_"^Minutes="_tMinutes_"^Seconds="_tSeconds
]]></Implementation>
</Method>

<Method name="SecDiff">
<Description>
Gets the difference in seconds between the two $H formated dates.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pHStart:%String,pHEnd:%String=$H</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tStartSecs = (+pHStart*86400)+$P(pHStart,",",2)
	Set tEndSecs = (+pHEnd*86400)+$P(pHEnd,",",2)
	Quit tEndSecs-tStartSecs
]]></Implementation>
</Method>

<Method name="GetProductionUptimeForNamespace">
<Description><![CDATA[
Gets the uptime string for a given namespace
If the stream is not null it will just append to the stream.
If pOnlyRunning is true the uptime lines for running productions will be returned
If pOnlyRunning is false (the default) then all productions that have ever been started will be added
including the status of production. The production won't be running so the uptime line will be empty
<br>
Example output with pOnlyRunning = 1
Namespace^ProductionName^Uptime Line
MC^MC.Personal^Running^Start Date=08 Dec 2011 10:37:37^Current Date=08 Dec 201111:37:23^Days=0^Hours=0^Minutes=59^Seconds=45.819
RUSHFTP^RushUniversity.FTP^Troubled^Start Date=25 Aug 2011 23:40:50^Current Date=08 Dec 2011 11:37:23^Days=104^Hours=11^Minutes=56^Seconds=32.647
<br>
Example output with pOnlyRunning = 0 (the default)
Namespace^ProductionName^Uptime Line
HSREGISTRY^HSREGISTRY.HubProduction^Stopped
MC^MC.Personal^Running^Start Date=08 Dec 2011 10:37:37^Current Date=08 Dec 201111:37:23^Days=0^Hours=0^Minutes=59^Seconds=45.819
RUSHFTP^RushUniversity.FTP^Troubled^Start Date=25 Aug 2011 23:40:50^Current Date=08 Dec 2011 11:37:23^Days=104^Hours=11^Minutes=56^Seconds=32.647]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNamespace:%String,&pUptimeStream:%Stream.TmpCharacter="",pOnlyRunning:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tOrigNS = $ZU(5)
	Set:pUptimeStream="" pUptimeStream = ##class(%Stream.TmpCharacter).%New()
	Try{
		ZN pNamespace
		Set tRS = ##class(%ResultSet).%New("Ens.Config.Production:ProductionStatus")
		If $IsObject(tRS) { //Not an Ensemble enabled namespace
			Set tStatus = tRS.Execute()
			If (tStatus=$$$OK) {
				While (tRS.Next()) {
					Set tProduction = tRS.Data("Production")
					Set tProdStatus = tRS.Data("Status")
					Set tLastStopTime=tRS.Data("LastStopTime")
					Set tLastStartTime = tRS.Data("LastStartTime")
					If (tLastStartTime'=""){ //Find only productions that have been started
						If (tLastStopTime=""){//If null then it is in some sort of up state
							Set tHStartTime = $ZDTH(tLastStartTime,3)
							Do pUptimeStream.WriteLine(pNamespace_"^"_tProduction _"^"_tRS.Data("Status")_"^"_..UptimeLine(tHStartTime,$H))
						}Else{
							Do:'pOnlyRunning pUptimeStream.WriteLine(pNamespace_"^"_tProduction _"^"_tRS.Data("Status"))
						}
					}
				}
			}
			Do tRS.Close()
		}
	}Catch(ex){ Set tStatus = ex.AsStatus()}
	Kill tRS
	ZN tOrigNS
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetProductionUptimes">
<Description>
Loops through all the namespaces in an instance and collects the 
Uptime lines for the productions in each namespace.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pUptimeStream:%Stream.TmpCharacter,pOnlyRunning:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pUptimeStream = ##class(%Stream.TmpCharacter).%New()
	Set tStatus = $$$OK
	Try{
		#;Get a list of all the instance namespaces
		Set tResultSet = ##class(%ResultSet).%New("%SYS.Namespace:List")
		#;0,0 = dont evaluate remote namespaces and don't connect to remote namespace
		Do tResultSet.Execute(0,0)
		While tResultSet.Next() {
			Set tNamespace = tResultSet.Data("Nsp")
			//Gets the uptime for a running production.
			Set tStatus = ..GetProductionUptimeForNamespace(tNamespace,.pUptimeStream,pOnlyRunning)
		}
		Do pUptimeStream.Rewind()
		Do tResultSet.Close()
	}Catch(ex){ Set tStatus = ex.AsStatus()}
	Kill tResultSet
	Quit tStatus
]]></Implementation>
</Method>

<Method name="DayAppError">
<Description>
Get all the application errors for the current day as defined in ^ERRORS(+$H)</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[  Quit $G(^ERRORS(+$H),0)
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.Util.OSCommand">
<Description>
A class to execute OS commands and return the OS output
including stdout, stderr, and the exit value of the command</Description>
<IncludeCode>%sySite</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>63336,38931.570407</TimeChanged>
<TimeCreated>63336,38931.570407</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/Util/OSCommand.xml#1 $</Default>
</Parameter>

<Method name="ExecutePipe">
<Description>
Execute an OS pipe command</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCmd:%String,&pOutput:%ListOfDataTypes,pRedirect:%Boolean=0,pIncludeStatus:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tTempBatchName =""
	Try {
		If pRedirect {
			Set pCmd = pCmd _ " 2>&1"
		}
		If pIncludeStatus {
			Set:$$$ISUNIX pCmd = pCmd _ "; echo 'OS command exit status='$?"
			If ($$$ISWINDOWS) {
				#;This currently always returns 0 regardless of success or failure
				#; Set:$$$ISWINDOWS pCmd = pCmd _" & echo status=%errorlevel%"
				#;Unfortunately it seems the only way to get the stdout,stderr and exit code
				#;back is to create a bat file and execute that.
				#;just running Open/Use pCmd will get the stderr and stdout back but no code
				#; $ZF(-1,pCmd) will get the exit code but no stderr and stdout
				#;Create a bat file to run and change pCmd to the file name
				Set tTempBatchName = $ZUTIL(168)_"OSBatchcmd"_+$H_$P($H,",",2)_".bat"
				Set tTempBatch = ##class(%File).%New(tTempBatchName)
				Set tStatus = tTempBatch.Open("WN")
				#;Do tTempBatch.WriteLine()
				Do tTempBatch.WriteLine("ECHO OFF")
				Do tTempBatch.WriteLine(pCmd)
				Do tTempBatch.WriteLine("echo OS command exit status=%errorlevel%")
				Do tTempBatch.Close()
				Set pCmd = tTempBatchName
			}
			////
		}
		#; Save off current device
		Set tIO=$IO		
		#; Open the pipe, saving output lines to pOutput array
		Try {
			Open pCmd:("QR"):5 If '$test $$$ThrowStatus($$$ERROR($$$GeneralError,"Unable to open shell command"))
			Use pCmd
			Set tEof=$zu(68,40,1)   //see %SYSTEM.Process.SetZEOF
			Set pOutput = ##class(%ListOfDataTypes).%New()
			For j=1:1 Quit:$zeof  Do
			. Read tLine
			. Set tLine=$tr(tLine,$c(13,10),"")
			. If tLine]"" Do pOutput.Insert(tLine)
			Set tEof=$zu(68,40,tEof)
		} Catch ex { Set tSC=ex.AsStatus() }
		#;Clean up the batch file if it exists
		If (tTempBatchName'=""){
			Set tStatus = ##class(%File).Delete(tTempBatchName)
			#;Remove the "ECHO OFF" statement from the results
			Do:pOutput.GetAt(1)["ECHO OFF" pOutput.RemoveAt(1)
		}
	
		#; Make sure we close the pipe and revert to original IO device
		Use tIO
		Close pCmd
	} Catch ex { 
		#;Clean up the batch file if it exists
		Set:tTempBatchName'="" tStatus = ##class(%File).Delete(tTempBatchName)
		Use tIO
		Close pCmd
		Set tSC=ex.AsStatus() 
	}	
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.Util.TrakMetrics">
<Description>
A util class that collects TrakCare metrics for monitoring.</Description>
<IncludeCode>%sySite,webutils</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>63336,42901.402782</TimeChanged>
<TimeCreated>63336,38975.421466</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/Util/TrakMetrics.xml#1 $</Default>
</Parameter>

<Method name="GetPrintStats">
<Description>
Calls the other Print stats routines and builds an array of the stats
This is just a simplifying wrapper to all the other print stat methods.
Array Keys:
Wait -- number of print jobs waiting as defined by websys.printhistory
InProgress -- number of print jobs in progress as defined by websys.printhistory
LastMinuteRequests -- the total number of print requests (regardles of status) in the last 60 seconds
LastHourPrintedRequests -- The total number of successfully printed requests for the last hour.
TodaysErrorCount -- The total number of print errors for today.

29/06/2014 - LP - Updated to use core macro to retrieve used Trakcare Licenses
             LP - Extended and Reviewed List of Components for performance ( to implement a configuration parameters for this ) 
				 LP - Fix Bug within GetEPSDaysOnLine when tTimeStamp=""</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
	Set tReturnArray = ##class(%ArrayOfDataTypes).%New()
	Do tReturnArray.SetAt(..PrintWaiting(),"Wait")
	Do tReturnArray.SetAt(..PrintInProgress(),"InProgress")
	Do tReturnArray.SetAt(..PrintRequests1Min(),"LastMinuteRequests")
	Do tReturnArray.SetAt(..PrintedRequests1Hour(),"LastHourPrintedRequests")
	Do tReturnArray.SetAt(..CurrentDayPrintErrorCount(),"TodaysErrorCount")
	Quit tReturnArray
]]></Implementation>
</Method>

<Method name="PrintWaiting">
<Description>
Returns the number of print jobs in waiting as defined by
the number of rows in websys.printhistory with a status of 'W'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit ..GetPrintCountForStatus("W")
]]></Implementation>
</Method>

<Method name="PrintInProgress">
<Description>
Returns the number of print jobs in progress as defined by
the number of rows in websys.printhistory with a status of 'I'</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit ..GetPrintCountForStatus("I")
]]></Implementation>
</Method>

<Method name="GetPrintCountForStatus">
<Description>
Returns the number of print jobs for a given status such as I for In Progress or 
W for the wait status.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStatus:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tPrintCount=0
	
	&sql(Select count(*) into :tPrintCount
		From websys.printhistory
		Where status=:pStatus)
	Quit tPrintCount
]]></Implementation>
</Method>

<Method name="PrintRequests1Min">
<Description>
Returns the number of print jobs, regardless of status, requested in the last
minute.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	Quit ..GetPrintCountByRange(60)
]]></Implementation>
</Method>

<Method name="PrintedRequests1Hour">
<Description>
Returns the number of printed jobs, a status of "P" ($LG(^websys.PrintHistoryD(x),19)="P"), 
requested in the last hour.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	Quit ..GetPrintCountByRange(3600,"P")
]]></Implementation>
</Method>

<Method name="GetPrintCountByRange">
<Description>
Generic method to get print counts for different ranges always assuming that the 
end date time is the current date time.
pSeconds is the number of seconds from the current date time that will be used as the 
beginning of the reported range.
pPrint type is either "" for all print requests or "P" for printed print requests.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSeconds:%Integer,pPrintStatus:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tCurrDateTime=$H
	Set tCurrDate = $P(tCurrDateTime,",",1)
	Set tCurrTime=$P(tCurrDateTime,",",2)
	Set tStartTime=tCurrTime-pSeconds
	Set tPrintCount=0

	If (tStartTime<0){
		#; Get the total number of seconds in a day (i.e. max value for $P($H,",",2))
		#; 60 seconds times 60 minutes * 24 hours = 86400 = ((60*60)*24)
		Set tEndTime = 86400
		#;tStartTime should be negative so adding it should make tStartTime less than tEndTime
		Set tStartTime = tEndTime + tStartTime
		#;Grab the count for the time part of the previous day
		Set tPrintCount = tPrintCount +..GetPrintCounts((tCurrDate-1),tStartTime,tEndTime,pPrintStatus)
		#;Set the start time to the first second of the current day
		Set tStartTime = 1
	} 
	Set tPrintCount = tPrintCount +..GetPrintCounts(tCurrDate,tStartTime,tCurrTime,pPrintStatus)
	Quit tPrintCount
]]></Implementation>
</Method>

<Method name="GetPrintCounts">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Integer,pStartTime:%Integer,pEndTime:%Integer,pPrintStatus:%String="P"</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tPrintCount=0
	If (pPrintStatus="") {//All requests
		Set tPrintCount = tPrintCount + ..GetPrintRequestsForRange(pDate,pStartTime,pEndTime)
	}Else{//Requests for a particular status
		Set tPrintCount = tPrintCount + ..GetPrintRequestsForRangeByStatus(pDate,pStartTime,pEndTime,pPrintStatus)
	}
	Quit tPrintCount
]]></Implementation>
</Method>

<Method name="GetPrintRequestsForRange">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Integer,pStartTime:%Integer,pEndTime:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tPrintCount = 0
	For tPrintTime=pStartTime:1:pEndTime {
		Set tPrintCount = tPrintCount + ..GetPrintRequestsForTime(pDate,tPrintTime)
	}	
	Quit tPrintCount
]]></Implementation>
</Method>

<Method name="GetPrintRequestsForTime">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Integer,pTime:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tPrintCount = 0
	Set x =""
	For { Set x=$O(^websys.PrintHistoryI("PrintDateIndex",pDate,pTime,x)) Quit:x=""
		Set tPrintCount=tPrintCount+1 
	}
	Quit tPrintCount
]]></Implementation>
</Method>

<Method name="GetPrintRequestsForRangeByStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Integer,pStartTime:%Integer,pEndTime:%Integer,pPrintStatus:%String="P"</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tPrintCount = 0
	For tPrintTime=pStartTime:1:pEndTime {
		Set tPrintCount = tPrintCount + ..GetPrintRequestsForTimeByStatus(pDate,tPrintTime,pPrintStatus)
	}	
	Quit tPrintCount
]]></Implementation>
</Method>

<Method name="GetPrintRequestsForTimeByStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDate:%Integer,pTime:%Integer,pPrintStatus:%String="P"</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tPrintCount = 0
	Set x = ""
	For { Set x=$O(^websys.PrintHistoryI("PrintDateIndex",pDate,pTime,x)) Quit:x=""
		If ($LG(^websys.PrintHistoryD(x),19)=pPrintStatus){
			Set tPrintCount=tPrintCount+1
		}
	}
	Quit tPrintCount
]]></Implementation>
</Method>

<Method name="CurrentDayPrintErrorCount">
<Description>
Returns the count of print errors for the current day(+$H), not the last 24 hours.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 Set tPrintID=""
 Set tPrintErr="0"
 For  { Set tPrintID=$O(^websys.PrintHistoryI("StatusIndex"," E",tPrintID),-1) Quit:tPrintID=""	
	Set tPrintDate=$LG(^websys.PrintHistoryD(tPrintID),21) Quit:(tPrintDate < +$H)
	Set tPrintErr=tPrintErr+1
 }
 Quit tPrintErr
]]></Implementation>
</Method>

<Method name="GetInterfacesStatus">
<ClassMethod>1</ClassMethod>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
  #; Return an array of datatypes containing the status of all interfaces 
  #; defined within Interface Workbench where the interface name is the array key.
  Set tInterfaceArray = ##class(%ArrayOfDataTypes).%New()
  Set tIntID=0
  Set tAllIntStatus=""
  For {  Set tIntID=$O(^SST("INT",tIntID)) Quit:tIntID=""
	     Set tIntName=$P($G(^SST("INT",tIntID)),"^",1) 
	     Set tIntStatus=..InterfaceStatus(tIntID, tIntName)
	     Do tInterfaceArray.SetAt(tIntStatus, tIntName)
  }
  Quit tInterfaceArray
]]></Implementation>
</Method>

<Method name="InterfaceStatus">
<Description>
Returns a carot (^) separated string for the interface identified by pIntID
InterfaceStatus^MessagesInQueue</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIntID:%Numeric,pIntName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 

 #; Get number of message in queue for the interface
 Set (tQueue,tXMsg)=""
 If $DATA(^SSHL7(pIntName,"QUEUE")){
	 For  Set tXMsg=$O(^SSHL7(pIntName,"QUEUE",tXMsg)) Set tQueue=tQueue+1 Quit:tXMsg="" 	
 }
 // Get Interface Status
 Set tInterfaceStatus=$P($G(^SST("INT",pIntID,"MON")),"^",1)
 
 Quit tInterfaceStatus_"^"_tQueue
]]></Implementation>
</Method>

<Method name="Licenses">
<Description>
Gets the licenses used as found in ^COUNT("ORDER",1)</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  ///Quit $G(^COUNT("ORDER",1),0) Legacy TC2010 Code
  s TCLicenses=$$$GetTCLicenceUsage
  Quit TCLicenses
]]></Implementation>
</Method>

<Method name="GetPerformanceMonitorCount">
<Description>
Returns an array (where the component name is the key and the average run is the value) 
that have an average execution time greater than pThreshold
over the pSampleSec range.  This always assumes the current day.  So, if the defaults are used, 
the count of components where the average runtime is over 2.5 seconds in the most 
recent 300 seconds.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSampleSec:%Integer=300,pThreshold:%Float=2.5</FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
	// Return the number of components slower than the Threshold
	//k ^TrakDashboard("CompPerformance")
	Set tReturnArray = ##class(%ArrayOfDataTypes).%New()
	Set tCurrentDateTime = $H
	Set tSeconds=$P(tCurrentDateTime,",",2)
	Set tCurrDay=$P(tCurrentDateTime,",",1)
	Set tStartSample=(tSeconds-pSampleSec)
	Set tStartSample=$O(^websys.MonitorI("DateTime",tCurrDay,tStartSample))
	If (tStartSample'=""){
		Set (tRowId,tStartRowId,tEndRowId) = ""
		Set tStartRowId=$O(^websys.MonitorI("DateTime",tCurrDay,tStartSample,tRowId))
		Set tEndRowId=$O(^websys.MonitorD(tEndRowId),-1) 
		Set tSQL="Select pName As ComponentName,AVG(pTime) As AverageTime,Count(pName) As InvokedTimes "
		Set tSQL = tSQL _ "from websys.Monitor "
		Set tSQL = tSQL _ "where ID >= ? and ID <= ? "
		Set tSQL = tSQL _ "and "
		Set tSQL = tSQL _ "(  pName ['OE' "
		Set tSQL = tSQL _ "or pName ['epr' "
		Set tSQL = tSQL _ "or pName ['PAAdm' "
		Set tSQL = tSQL _ "or pName ['PAPerson' "
		Set tSQL = tSQL _ "or pName ['floorplan' "
		Set tSQL = tSQL _ "or pName ['RB' "
		Set tSQL = tSQL _ "or pName ['websys' "
		Set tSQL = tSQL _ "or pName ['Voice.Link') "
		Set tSQL = tSQL _ "group by pName HAVING AVG(pTime) >= ? "
		#;W tSQL,!
		#;W tStartRowId,!
		#;W tEndRowId,!
		#;W pThreshold,!
		Set tResultSet=##class(%ResultSet).%New("%DynamicQuery:SQL")
		Set tStatus=tResultSet.Prepare(tSQL)
		Set tStatus=tResultSet.Execute(tStartRowId,tEndRowId,pThreshold)
		While tResultSet.Next() {
	 		#;Set ComponentName = tResultSet.Data("ComponentName")
	 	 	#;Set InvokedTimes = tResultSet.Data("InvokedTimes")
	 		#;Set AvgTime = tResultSet.Data("AverageTime") 
	 		Do tReturnArray.SetAt(tResultSet.Data("AverageTime"),tResultSet.Data("ComponentName"))
	    }
	}

	Quit tReturnArray
]]></Implementation>
</Method>

<Method name="GetEPSDebug">
<Description>
Returns the zero or the value of the Zen debug flag (^CacheTemp.ZEN("DebugZen","NoDelete"))</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit $G(^CacheTemp.ZEN("DebugZen","NoDelete"),0)
]]></Implementation>
</Method>

<Method name="GetEPSProductionStatus">
<Description>
Returns the status of the production in the current namespace where:
         1=$$$eProductionStateRunning
         2=$$$eProductionStateStopped
         3=$$$eProductionStateSuspended
         4-$$$eProductionStateTroubled</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set (tName,tState)=""
	Do ##class(Ens.Director).GetProductionStatus(.tName,.tState)
	Quit tState
]]></Implementation>
</Method>

<Method name="GetEPSDaysOnLine">
<Description>
Not exactly sure what this is doing.  It looks like it returns
The age in days of the oldest message on-line/not purged</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tTimeStamp=""
	Set tDayEpsMsg=0
	Set tTimeStamp=$O(^Ens.MessageHeaderI("TimeCreated",tTimeStamp))
	i tTimeStamp'="" {
			Set tDate=$P(tTimeStamp," ",1)
			Set tCacheDate=$zdh(tDate,3)
			Set tDayEpsMsg=+$H-tCacheDate
	}
	Quit tDayEpsMsg
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.WS.ShadowCheck">
<Description>
A simple web service that returns the values of some globals.
Called by a client on the source server that is being shadowed to 
check if the two instances are staying in sync.</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SOAP.WebService</Super>
<TimeChanged>63336,39487.173585</TimeChanged>
<TimeCreated>63336,39043.305055</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/WS/ShadowCheck.xml#1 $</Default>
</Parameter>

<Parameter name="SERVICENAME">
<Default>ShadowCheck</Default>
</Parameter>

<Parameter name="EndTimeCheck">
<Type>%String</Type>
<Default>END GLOBAL DATA</Default>
</Parameter>

<Method name="GetShadowStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:%String</FormalSpec>
<ReturnType>%Stream.TmpCharacter</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tReturn = ##class(%Stream.TmpCharacter).%New()
	Set tArray = ..GetGlobalValues(pRequest)
	Set tKey = ""
	Set tValue = tArray.GetNext(.tKey)
	While tKey'=""{
		Do tReturn.WriteLine(tKey_"="_tValue)
		Set tValue = tArray.GetNext(.tKey)
	}
	Do tReturn.WriteLine(..#EndTimeCheck)
	Set tStatus = ..GetQueryResults(.tReturn)
	
	Quit tReturn
]]></Implementation>
</Method>

<Method name="GetGlobalValues">
<Description>
Loops over the list of globals and sets an array with the value
pGlobalList is expected to be formatted like this ^GlobalName(0):Namespace~^GlobalName(1):Namespace
And the array returned will use the global name as the key and the global value as the value in the array.
This method with switch to the appropriate namespace to determine the value.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlobalList:%String</FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tResults = ##class(%ArrayOfDataTypes).%New()
	Set tOrigNS = $ZU(5)
	Set (tNewNS,tOldNS) = ""
	Try{
		For i=1:1:$L(pGlobalList,"~"){
			Set tGlobalNS = $P(pGlobalList,"~",i)
			Set tGlobal = $P(tGlobalNS,":",1)
			Set tNewNS = $P(tGlobalNS,":",2)
			If (tNewNS'=tOldNS) zn tNewNS
			Set tStatus = tResults.SetAt($G(@tGlobal,""), tGlobalNS)
			Set tOldNS = tNewNS
		}
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}	
	zn tOrigNS
	Quit tResults
]]></Implementation>
</Method>

<Method name="GetQueryResults">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pReturn:%Stream.TmpCharacter]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tOrigNS = $ZU(5)
	Set tResultSet =""
	Set tListOfDirectories = ##class(%ListOfDataTypes).%New()
	Set tArrayOfErrors = ##class(%ArrayOfDataTypes).%New()
	Try{
		zn "%SYS"
        If '$SYSTEM.Security.Check("%Admin_Operate","USE"){
	    	$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation requires %Admin_Operate:Use privilege"))
        }
        Set tResultSet = ##class(%Library.ResultSet).%New("SYS.Shadowing.Shadow:Progress")
        #;Set tResultSet.RuntimeMode=2
        Set tStatus=tResultSet.Execute() 
        If $$$ISERR(tStatus) $$$ThrowStatus($$$ERROR($$$GeneralError,"Error executing shadow status query: "_ tStatus))
        #;Do pReturn.WriteLine(..Format("Name",16,"_")_..Format("Status",18,"_")_..Format("Latency",16,"_")_..Format("#Errors",8,"_")_..Format("#Open Trans",12,"_"))
        While tResultSet.Next() {
	        Set tJournalName = tResultSet.Data("Name")
	        Set tErrors = tResultSet.Data("Errors")
	        If (tErrors > 0) Do tArrayOfErrors.SetAt(tErrors,tJournalName)
			#;Set tStatus = pReturn.WriteLine(..Format(tJournalName,16,"_")_..Format(tResultSet.Data("Status"),18,"_")_..Format(tResultSet.Data("Latency"),16,"_")_..Format(tErrors,8,"_")_..Format(tResultSet.Data("Open Transactions"),12,"_"))
			Do pReturn.WriteLine("Status for: "_tJournalName)
			Do pReturn.WriteLine("Status:"_tResultSet.Data("Status"))
			Do pReturn.WriteLine("Latency:"_tResultSet.Data("Latency"))
			Do pReturn.WriteLine("Errors:"_tErrors)
			Do pReturn.WriteLine("Open Transactions:"_tResultSet.Data("Open Transactions"))
			Do pReturn.WriteLine(..Format("",150,"_"))
			Do pReturn.WriteLine("")
			Set tShadow = ##class(SYS.Shadowing.Shadow).%OpenId(tJournalName)
			Do tListOfDirectories.Insert(tShadow.JournalStore)
        }
        Do tResultSet.Close()
        Set:tArrayOfErrors.Count() tStatus = ..getShadowErrors(tArrayOfErrors,.pReturn)
        zn tOrigNS
        Set tStatus = ..getJournalDirectoryList(tListOfDirectories,.pReturn)
        Do pReturn.Rewind()
	}Catch(ex){
		Set tStatus = ex.AsStatus()
		Set ^MDL("ERROR")=tStatus
		Do:$IsObject(tResultSet) tResultSet.Close()
	}
	zn tOrigNS
	Quit tStatus
]]></Implementation>
</Method>

<Method name="Format">
<ClassMethod>1</ClassMethod>
<FormalSpec>pValue:%String,pSize,pFill</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $Replace($J(pValue,pSize),$J("",(pSize-$L(pValue))),$TR($J(pFill,(pSize-$L(pValue)))," ",pFill))
]]></Implementation>
</Method>

<Method name="getShadowErrors">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pArrayOfErrors:%ArrayOfDataTypes,&pReport:%GlobalCharacterStream]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
        Set tShadowInstance = ""

        While pArrayOfErrors.GetNext(.tShadowInstance){	        
	        Set tResultSet = ##class(%Library.ResultSet).%New("SYS.Shadowing.Shadow:Errors")
        
	        Set tStatus=tResultSet.Execute(tShadowInstance) 
	        Do pReport.WriteLine()
	        Do pReport.WriteLine("Errors found for "_tShadowInstance)
	        #;Do pReport.WriteLine(..Format("Time",20,"_")_..Format("PID",8,"_")_..Format("ZERROR",30,"_")_..Format("Text",130,"_")_..Format("Reoccurrences",15,"_")_..Format("First Occurred At",20,"_"))
	        While tResultSet.Next() {
				#;Set tStatus = pReport.WriteLine(..Format(tResultSet.Data("Time"),20,"_")_..Format(tResultSet.Data("PID"),8,"_")_..Format(tResultSet.Data("$ZERROR"),30,"_")_..Format(tResultSet.Data("Text"),130,"_")_..Format(tResultSet.Data("Reoccurrences"),15,"_")_..Format(tResultSet.Data("First Occurred At"),20,"_"))
				Set tStatus = pReport.WriteLine("Time:"_tResultSet.Data("Time"))
				Set tStatus = pReport.WriteLine("PID:"_tResultSet.Data("PID"))
				Set tStatus = pReport.WriteLine("$ZERROR:"_tResultSet.Data("$ZERROR"))
				Set tStatus = pReport.WriteLine("Text:"_tResultSet.Data("Text"))
				Set tStatus = pReport.WriteLine("Reoccurrences:"_tResultSet.Data("Reoccurrences"))
				Set tStatus = pReport.WriteLine("First Occurred At:"_tResultSet.Data("First Occurred At"))
				Do pReport.WriteLine()
	        }
	        Do tResultSet.Close()
	        Do pReport.WriteLine(..Format("",150,"_"))
        }        
	}Catch(ex){
		Set tStatus = ex.AsStatus()
	}	
	Quit tStatus
]]></Implementation>
</Method>

<Method name="getJournalDirectoryList">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDirectory:%ListOfDataTypes,&pReport:%GlobalCharacterStream]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	For i=1:1:pDirectory.Count() {
		Set tDirectory = pDirectory.GetAt(i)
		Set tStatus = ##class(zCustom.TC.Task.Util.OSCommand).ExecutePipe("ls -l " _ tDirectory, .tOutput,0,0)
		Do pReport.WriteLine()
		Do pReport.WriteLine()
		Do pReport.WriteLine("Directory Listing for " _tDirectory)
		For j=1:1:tOutput.Count(){
			Do pReport.WriteLine(tOutput.GetAt(j))
		}
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="zCustom.TC.Task.WSClient.ShadowCheckSoap">
<ProcedureBlock>1</ProcedureBlock>
<Super>%SOAP.WebClient</Super>
<TimeChanged>63336,39504.517824</TimeChanged>
<TimeCreated>63336,39097.055173</TimeCreated>

<Parameter name="SrcVer">
<Description>
Location and Revision of this file in Perforce (Auto-updating)</Description>
<Default>$Id: //custom_ccrs/scx/SCXX/T2010/LIVE/cls/Custom/TC/Task/WSClient/ShadowCheckSoap.xml#1 $</Default>
</Parameter>

<Parameter name="LOCATION">
<Description>
This is the URL used to access the web service.</Description>
<Default>http://locallinux:57772/csp/user/zCustom.TC.Task.WS.ShadowCheck.cls</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
This is the namespace used by the Service</Description>
<Default>http://tempuri.org</Default>
</Parameter>

<Parameter name="OUTPUTTYPEATTRIBUTE">
<Description>
Use xsi:type attribute for literal types.</Description>
<Default>1</Default>
</Parameter>

<Parameter name="SERVICENAME">
<Description>
This is the name of the Service</Description>
<Default>ShadowCheck</Default>
</Parameter>

<Parameter name="SOAPVERSION">
<Description>
This is the SOAP version supported by the service.</Description>
<Default>1.1</Default>
</Parameter>

<Method name="GetShadowStatus">
<Final>1</Final>
<FormalSpec>pRequest:%String</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Stream.TmpCharacter</ReturnType>
<WebMethod>1</WebMethod>
<SoapBindingStyle>document</SoapBindingStyle>
<SoapBodyUse>literal</SoapBodyUse>
<Implementation><![CDATA[ Quit ..WebMethod("GetShadowStatus").Invoke($this,"http://tempuri.org/zCustom.TC.Task.WS.ShadowCheck.GetShadowStatus",.pRequest)
]]></Implementation>
</Method>
</Class>
</Export>
